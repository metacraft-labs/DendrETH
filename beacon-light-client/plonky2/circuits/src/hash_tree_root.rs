use plonky2::{
    field::extension::Extendable, hash::hash_types::RichField, iop::target::BoolTarget,
    plonk::circuit_builder::CircuitBuilder,
};
use plonky2_sha256::circuit::{make_circuits, Sha256Targets};

use crate::utils::create_bool_target_array;

pub struct HashTreeRootTargets {
    pub leaves: Vec<[BoolTarget; 256]>,
    pub hash_tree_root: [BoolTarget; 256],
}

pub fn hash_tree_root<F: RichField + Extendable<D>, const D: usize>(
    builder: &mut CircuitBuilder<F, D>,
    leaves_len: usize,
) -> HashTreeRootTargets {
    let leaves: Vec<[BoolTarget; 256]> = (0..leaves_len)
        .map(|_| create_bool_target_array(builder))
        .collect();

    let mut hashers: Vec<Sha256Targets> = Vec::new();

    for i in 0..(leaves_len / 2) {
        hashers.push(make_circuits(builder, 512));

        for j in 0..256 {
            builder.connect(hashers[i].message[j].target, leaves[i * 2][j].target);
            builder.connect(
                hashers[i].message[j + 256].target,
                leaves[i * 2 + 1][j].target,
            );
        }
    }

    let mut k = 0;
    for i in leaves_len / 2..leaves_len - 1 {
        hashers.push(make_circuits(builder, 512));

        for j in 0..256 {
            builder.connect(
                hashers[i].message[j].target,
                hashers[k * 2].digest[j].target,
            );
            builder.connect(
                hashers[i].message[j + 256].target,
                hashers[k * 2 + 1].digest[j].target,
            );
        }

        k += 1;
    }

    HashTreeRootTargets {
        leaves: leaves,
        hash_tree_root: hashers[leaves_len - 2].digest.clone().try_into().unwrap(),
    }
}

#[cfg(test)]
mod tests {
    use anyhow::Result;
    use plonky2::{
        field::goldilocks_field::GoldilocksField,
        iop::witness::{PartialWitness, WitnessWrite},
        plonk::{
            circuit_builder::CircuitBuilder, circuit_data::CircuitConfig,
            config::PoseidonGoldilocksConfig,
        },
    };

    use crate::{hash_tree_root::hash_tree_root, utils::hash_bit_array};

    #[test]
    fn test_hash_tree_root() -> Result<()> {
        const D: usize = 2;
        type C = PoseidonGoldilocksConfig;
        type F = GoldilocksField;

        let mut builder = CircuitBuilder::<F, D>::new(CircuitConfig::standard_recursion_config());

        let targets = hash_tree_root(&mut builder, 4);

        let mut pw: PartialWitness<F> = PartialWitness::new();

        let first = vec![
            "0", "1", "1", "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1",
            "0", "0", "0", "1", "1", "0", "1", "0", "0", "0", "0", "0", "1", "1", "0", "1", "1",
            "1", "0", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "0", "0", "1", "0", "1",
            "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "0", "1", "1", "0",
            "1", "1", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "1", "1", "0", "0", "0",
            "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0",
            "1", "0", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0", "0", "0", "0", "1", "0",
            "0", "1", "1", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0",
            "0", "1", "0", "0", "1", "1", "0", "0", "0", "1", "1", "0", "1", "1", "0", "1", "0",
            "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "1", "1",
            "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1", "1", "0", "0", "0", "1",
            "1", "1", "0", "0", "0", "1", "0", "0", "0", "1", "0", "0", "1", "0", "1", "1", "0",
            "1", "1", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1", "0", "0", "1", "1", "0",
            "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0",
            "1",
        ];

        let second = vec![
            "0", "0", "1", "1", "0", "1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "1",
            "0", "0", "1", "0", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1",
            "1", "0", "1", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "1", "1",
            "1", "1", "0", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "1", "0", "1",
            "0", "0", "1", "0", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "0", "1",
            "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "0", "0", "1", "1", "1", "1", "0",
            "1", "0", "1", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "0", "1",
            "0", "1", "0", "1", "1", "1", "0", "1", "1", "0", "0", "1", "1", "1", "1", "1", "1",
            "0", "1", "0", "1", "1", "0", "1", "0", "0", "1", "1", "0", "0", "0", "1", "0", "0",
            "0", "1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "0", "0", "0", "1", "0",
            "1", "1", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "1", "1", "1",
            "1", "1", "0", "0", "1", "0", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "0",
            "1", "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1",
            "0", "0", "1", "1", "1", "1", "0", "1", "0", "1", "1", "0", "0", "0", "0", "0", "0",
            "1", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "1",
            "0",
        ];

        let third = vec![
            "1", "0", "0", "1", "1", "1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "0", "0",
            "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1", "0", "1",
            "1", "1", "0", "0", "0", "0", "0", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1",
            "0", "1", "0", "1", "0", "1", "1", "1", "1", "1", "1", "0", "0", "1", "0", "0", "1",
            "1", "0", "0", "0", "1", "1", "0", "1", "1", "0", "0", "1", "0", "0", "0", "0", "1",
            "1", "1", "0", "0", "0", "1", "0", "1", "0", "1", "0", "1", "1", "1", "0", "1", "0",
            "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "0",
            "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "1",
            "1", "0", "0", "0", "1", "1", "0", "0", "1", "1", "0", "1", "1", "1", "0", "0", "1",
            "0", "0", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1", "0", "0", "1",
            "1", "0", "0", "1", "1", "1", "1", "1", "0", "0", "0", "1", "1", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "1",
            "1", "0", "1", "0", "0", "1", "1", "1", "1", "0", "0", "0", "0", "0", "1", "1", "0",
            "1", "1", "0", "0", "0", "1", "0", "0", "1", "1", "1", "0", "1", "0", "0", "0", "0",
            "0", "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "0",
            "0",
        ];

        let fourth = vec![
            "1", "1", "0", "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0",
            "1", "0", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "0",
            "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0", "1", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "1",
            "1", "0", "1", "1", "1", "1", "0", "0", "1", "0", "0", "1", "0", "1", "0", "1", "1",
            "0", "1", "0", "0", "1", "1", "0", "1", "0", "0", "1", "0", "0", "0", "1", "1", "0",
            "0", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0",
            "1", "1", "1", "0", "1", "1", "0", "1", "0", "1", "1", "0", "1", "1", "1", "1", "1",
            "0", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0",
            "0", "0", "0", "0", "1", "0", "1", "1", "0", "0", "1", "0", "0", "1", "0", "0", "0",
            "0", "1", "1", "0", "1", "1", "1", "1", "1", "0", "1", "0", "0", "0", "1", "0", "1",
            "0", "0", "0", "0", "1", "1", "1", "1", "1", "0", "0", "1", "1", "1", "0", "1", "0",
            "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "1", "1", "1",
            "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0", "0", "1", "0", "0",
            "0", "0", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "0", "0", "0",
            "1",
        ];

        let hash_tree_root = vec![
            "1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "1", "1", "1", "0", "0", "1",
            "1", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1",
            "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0", "1", "0", "1",
            "1", "1", "0", "0", "1", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0",
            "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "0", "1", "1", "1",
            "0", "1", "1", "0", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "0", "0", "1",
            "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "1", "1", "1", "1",
            "1", "0", "0", "1", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0",
            "0", "1", "1", "0", "1", "1", "1", "0", "0", "0", "0", "0", "1", "1", "0", "1", "0",
            "1", "0", "1", "1", "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0",
            "0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "1", "1",
            "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1",
            "0", "1", "0", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "1", "1",
            "1", "0", "1", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0", "1", "0", "1",
            "1", "1", "0", "0", "0", "0", "0", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1",
            "0",
        ];

        for i in 0..256 {
            pw.set_bool_target(targets.leaves[0][i], first[i] == "1");
            pw.set_bool_target(targets.leaves[1][i], second[i] == "1");
            pw.set_bool_target(targets.leaves[2][i], third[i] == "1");
            pw.set_bool_target(targets.leaves[3][i], fourth[i] == "1");
        }

        for i in 0..256 {
            if hash_tree_root[i] == "1" {
                builder.assert_one(targets.hash_tree_root[i].target);
            } else {
                builder.assert_zero(targets.hash_tree_root[i].target);
            }
        }

        let data = builder.build::<C>();
        let proof = data.prove(pw).unwrap();

        data.verify(proof)
    }

    #[test]
    fn validators_hash_tree_root() -> Result<()> {
        let validator_pubkey = [
            "1", "0", "0", "1", "0", "0", "1", "1", "0", "0", "1", "1", "1", "0", "1", "0", "1",
            "1", "0", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "0", "1", "0", "0",
            "0", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0", "0", "0",
            "0", "0", "1", "0", "1", "1", "0", "0", "1", "1", "1", "0", "1", "1", "1", "0", "1",
            "0", "0", "0", "0", "0", "1", "1", "0", "0", "1", "0", "1", "1", "0", "1", "1", "0",
            "1", "0", "1", "0", "1", "1", "0", "0", "0", "0", "0", "1", "1", "0", "1", "0", "0",
            "1", "0", "0", "1", "0", "1", "0", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0",
            "0", "1", "0", "0", "1", "0", "1", "0", "1", "0", "1", "1", "1", "1", "0", "1", "0",
            "1", "0", "0", "0", "1", "1", "0", "0", "0", "1", "0", "0", "0", "0", "0", "0", "0",
            "0", "1", "0", "1", "1", "0", "0", "1", "1", "0", "0", "0", "1", "1", "0", "1", "1",
            "1", "0", "1", "0", "0", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "1", "1",
            "0", "1", "1", "1", "0", "0", "1", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1",
            "0", "0", "0", "0", "1", "0", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0",
            "0", "0", "1", "1", "1", "1", "0", "1", "0", "0", "0", "1", "1", "1", "1", "0", "1",
            "1", "1", "0", "0", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "0", "1",
            "0", "0", "1", "1", "0", "0", "1", "1", "1", "1", "0", "1", "0", "1", "0", "0", "0",
            "1", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "0", "0",
            "0", "1", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1", "0", "1", "0", "0",
            "1", "0", "1", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "0", "1", "1", "0",
            "0", "0", "1", "0", "1", "0", "0", "1", "0", "1", "0", "1", "0", "1", "1", "1", "0",
            "0", "0", "0", "1", "0", "0", "1", "1", "0", "1", "0", "0", "0", "0", "1", "0", "1",
            "0", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "0", "0", "1", "1",
            "0", "0", "1", "0", "0", "1", "0", "1", "0", "1",
        ];

        let withdraw_credentials = [
            "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "1",
            "0", "1", "0", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "1", "1", "0", "1",
            "1", "1", "0", "1", "1", "0", "1", "0", "0", "1", "0", "0", "1", "1", "1", "1", "0",
            "1", "1", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "0", "0", "0", "1", "0",
            "0", "0", "0", "0", "0", "0", "0", "1", "1", "1", "1", "1", "1", "0", "1", "0", "0",
            "1", "1", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "1", "0", "1", "0", "1",
            "0", "1", "0", "0", "1", "1", "1", "1", "1", "1", "0", "0", "0", "0", "0", "1", "0",
            "1", "0", "0", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "1", "0", "1", "1",
            "1", "0", "1", "1", "0", "1", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "1",
            "0", "1", "0", "0", "1", "0", "1", "1", "0", "1", "0", "1", "0", "1", "0", "0", "0",
            "0",
        ];

        let effective_balance = [
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "0", "0",
            "1", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "0",
            "0", "0", "0", "1", "1", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0",
        ];

        let slashed = [
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0",
        ];

        let activation_eligibility_epoch = [
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0",
        ];

        let withdrawable_epoch = [
            "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
            "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
            "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
            "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0",
            "0",
        ];

        let validator_hash_tree_root = [
            "0", "0", "1", "0", "1", "0", "1", "1", "1", "0", "1", "0", "1", "1", "1", "1", "0",
            "1", "0", "0", "0", "0", "0", "0", "0", "1", "1", "0", "0", "1", "0", "1", "1", "0",
            "1", "1", "0", "1", "0", "1", "1", "1", "0", "1", "0", "1", "1", "0", "0", "0", "1",
            "0", "0", "1", "0", "0", "0", "1", "1", "0", "0", "1", "0", "0", "0", "0", "0", "1",
            "0", "0", "0", "0", "0", "1", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0", "1",
            "1", "0", "0", "0", "1", "1", "1", "1", "0", "0", "1", "1", "0", "0", "0", "0", "0",
            "0", "1", "1", "1", "1", "0", "0", "1", "0", "1", "0", "1", "0", "1", "0", "0", "0",
            "0", "0", "1", "1", "1", "1", "1", "0", "0", "1", "1", "1", "0", "1", "0", "0", "0",
            "0", "0", "1", "0", "1", "1", "0", "1", "0", "1", "0", "0", "0", "1", "1", "0", "1",
            "1", "0", "1", "1", "0", "0", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1", "0",
            "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "1", "0", "0", "1", "1", "1", "0",
            "1", "1", "1", "1", "1", "0", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "0",
            "0", "0", "1", "1", "1", "0", "0", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0",
            "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0",
            "1", "1", "0", "0", "0", "0", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", "0",
            "1",
        ];

        const D: usize = 2;
        type C = PoseidonGoldilocksConfig;
        type F = GoldilocksField;

        let pubkey_binary_result = hash_bit_array(validator_pubkey.to_vec());

        let mut builder = CircuitBuilder::<F, D>::new(CircuitConfig::standard_recursion_config());

        let targets = hash_tree_root(&mut builder, 8);

        let mut pw: PartialWitness<F> = PartialWitness::new();

        for i in 0..256 {
            pw.set_bool_target(targets.leaves[0][i], pubkey_binary_result[i] == "1");
            pw.set_bool_target(targets.leaves[1][i], withdraw_credentials[i] == "1");
            pw.set_bool_target(targets.leaves[2][i], effective_balance[i] == "1");
            pw.set_bool_target(targets.leaves[3][i], slashed[i] == "1");
            pw.set_bool_target(targets.leaves[4][i], activation_eligibility_epoch[i] == "1");
            pw.set_bool_target(targets.leaves[5][i], false);
            pw.set_bool_target(targets.leaves[6][i], if i < 64 { true } else { false });
            pw.set_bool_target(targets.leaves[7][i], withdrawable_epoch[i] == "1");
        }

        for i in 0..256 {
            if validator_hash_tree_root[i] == "1" {
                builder.assert_one(targets.hash_tree_root[i].target);
            } else {
                builder.assert_zero(targets.hash_tree_root[i].target);
            }
        }

        let data = builder.build::<C>();
        let proof = data.prove(pw).unwrap();

        data.verify(proof)
    }

    #[test]
    #[should_panic]
    fn test_hash_tree_root_failure() {
        const D: usize = 2;
        type C = PoseidonGoldilocksConfig;
        type F = GoldilocksField;

        let mut builder = CircuitBuilder::<F, D>::new(CircuitConfig::standard_recursion_config());

        let targets = hash_tree_root(&mut builder, 4);

        let mut pw: PartialWitness<F> = PartialWitness::new();

        let first = vec![
            "0", "1", "1", "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1",
            "0", "0", "0", "1", "1", "0", "1", "0", "0", "0", "0", "0", "1", "1", "0", "1", "1",
            "1", "0", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "0", "0", "1", "0", "1",
            "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "0", "1", "1", "0",
            "1", "1", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "1", "1", "0", "0", "0",
            "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0",
            "1", "0", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0", "0", "0", "0", "1", "0",
            "0", "1", "1", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "1", "0", "0", "0",
            "0", "1", "0", "0", "1", "1", "0", "0", "0", "1", "1", "0", "1", "1", "0", "1", "0",
            "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "1", "1",
            "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1", "1", "0", "0", "0", "1",
            "1", "1", "0", "0", "0", "1", "0", "0", "0", "1", "0", "0", "1", "0", "1", "1", "0",
            "1", "1", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1", "0", "0", "1", "1", "0",
            "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0",
            "1",
        ];

        let second = vec![
            "0", "0", "1", "1", "0", "1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "1",
            "0", "0", "1", "0", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1",
            "1", "0", "1", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "1", "1",
            "1", "1", "0", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "1", "0", "1",
            "0", "0", "1", "0", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0", "1", "0", "1",
            "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "0", "0", "1", "1", "1", "1", "0",
            "1", "0", "1", "0", "0", "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "0", "1",
            "0", "1", "0", "1", "1", "1", "0", "1", "1", "0", "0", "1", "1", "1", "1", "1", "1",
            "0", "1", "0", "1", "1", "0", "1", "0", "0", "1", "1", "0", "0", "0", "1", "0", "0",
            "0", "1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "0", "0", "0", "1", "0",
            "1", "1", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "1", "1", "1",
            "1", "1", "0", "0", "1", "0", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "0",
            "1", "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1",
            "0", "0", "1", "1", "1", "1", "0", "1", "0", "1", "1", "0", "0", "0", "0", "0", "0",
            "1", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "1",
            "0",
        ];

        let third = vec![
            "1", "0", "0", "1", "1", "1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "0", "0",
            "0", "0", "0", "0", "0", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1", "0", "1",
            "1", "1", "0", "0", "0", "0", "0", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1",
            "0", "1", "0", "1", "0", "1", "1", "1", "1", "1", "1", "0", "0", "1", "0", "0", "1",
            "1", "0", "0", "0", "1", "1", "0", "1", "1", "0", "0", "1", "0", "0", "0", "0", "1",
            "1", "1", "0", "0", "0", "1", "0", "1", "0", "1", "0", "1", "1", "1", "0", "1", "0",
            "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "0",
            "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "1",
            "1", "0", "0", "0", "1", "1", "0", "0", "1", "1", "0", "1", "1", "1", "0", "0", "1",
            "0", "0", "0", "1", "1", "0", "0", "1", "0", "1", "1", "1", "0", "1", "0", "0", "1",
            "1", "0", "0", "1", "1", "1", "1", "1", "0", "0", "0", "1", "1", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "0", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "1",
            "1", "0", "1", "0", "0", "1", "1", "1", "1", "0", "0", "0", "0", "0", "1", "1", "0",
            "1", "1", "0", "0", "0", "1", "0", "0", "1", "1", "1", "0", "1", "0", "0", "0", "0",
            "0", "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "0",
            "0",
        ];

        let fourth = vec![
            "1", "1", "0", "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0",
            "1", "0", "1", "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "0",
            "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0", "1", "1", "0", "1", "0",
            "0", "0", "0", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "1", "0", "0", "1",
            "1", "0", "1", "1", "1", "1", "0", "0", "1", "0", "0", "1", "0", "1", "0", "1", "1",
            "0", "1", "0", "0", "1", "1", "0", "1", "0", "0", "1", "0", "0", "0", "1", "1", "0",
            "0", "1", "0", "0", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0",
            "1", "1", "1", "0", "1", "1", "0", "1", "0", "1", "1", "0", "1", "1", "1", "1", "1",
            "0", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0",
            "0", "0", "0", "0", "1", "0", "1", "1", "0", "0", "1", "0", "0", "1", "0", "0", "0",
            "0", "1", "1", "0", "1", "1", "1", "1", "1", "0", "1", "0", "0", "0", "1", "0", "1",
            "0", "0", "0", "0", "1", "1", "1", "1", "1", "0", "0", "1", "1", "1", "0", "1", "0",
            "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "1", "1", "1",
            "0", "0", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0", "0", "1", "0", "0",
            "0", "0", "0", "1", "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "0", "0", "0",
            "1",
        ];

        let hash_tree_root = vec![
            "1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "1", "1", "1", "0", "0", "1",
            "1", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "1",
            "1", "1", "1", "1", "1", "0", "1", "1", "0", "0", "0", "1", "0", "0", "1", "0", "1",
            "1", "1", "0", "0", "1", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0", "1", "0",
            "1", "0", "1", "1", "1", "1", "0", "1", "0", "0", "1", "0", "1", "0", "1", "1", "1",
            "0", "1", "1", "0", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1", "0", "0", "1",
            "1", "0", "0", "1", "0", "1", "0", "0", "1", "0", "1", "1", "0", "1", "1", "1", "1",
            "1", "0", "0", "1", "0", "0", "1", "0", "1", "1", "1", "0", "0", "0", "0", "1", "0",
            "0", "1", "1", "0", "1", "1", "1", "0", "0", "0", "0", "0", "1", "1", "0", "1", "0",
            "1", "0", "1", "1", "0", "1", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "0",
            "0", "0", "0", "0", "1", "0", "0", "0", "0", "0", "1", "1", "1", "0", "1", "1", "1",
            "0", "0", "1", "0", "0", "0", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1",
            "0", "1", "0", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "1", "1", "1", "1",
            "1", "0", "1", "1", "1", "1", "0", "0", "1", "1", "0", "0", "1", "0", "1", "0", "1",
            "1", "1", "0", "0", "0", "0", "0", "1", "0", "1", "1", "0", "1", "0", "0", "0", "1",
            "1",
        ];

        for i in 0..256 {
            pw.set_bool_target(targets.leaves[0][i], first[i] == "1");
            pw.set_bool_target(targets.leaves[1][i], second[i] == "1");
            pw.set_bool_target(targets.leaves[2][i], third[i] == "1");
            pw.set_bool_target(targets.leaves[3][i], fourth[i] == "1");
        }

        for i in 0..256 {
            if hash_tree_root[i] == "1" {
                builder.assert_one(targets.hash_tree_root[i].target);
            } else {
                builder.assert_zero(targets.hash_tree_root[i].target);
            }
        }

        let data = builder.build::<C>();
        let proof = data.prove(pw).unwrap();

        data.verify(proof).expect("")
    }
}
