#![feature(prelude_import)]
#![feature(generic_const_exprs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod circuit_input_common {
    use crate::{
        deposits_accumulator_balance_aggregator::validator_balance_circuit_accumulator::{
            DepositDataTarget, ValidatorBalanceVerificationAccumulatorTargets,
        },
        final_layer::build_final_circuit::FinalCircuitTargets,
        serializers::{
            biguint_to_str, bool_vec_as_int_vec, bool_vec_as_int_vec_nested,
            parse_biguint, ValidatorShaInput,
        },
        utils::{
            biguint::WitnessBigUint,
            hashing::{
                validator_hash_tree_root::ValidatorShaTargets,
                validator_hash_tree_root_poseidon::ValidatorTarget,
            },
            utils::SetBytesArray,
        },
        validators_commitment_mapper::first_level::ValidatorsCommitmentMapperFirstLevel,
        withdrawal_credentials_balance_aggregator::first_level::{
            ValidatorBalanceVerificationTargets,
            WithdrawalCredentialsBalanceAggregatorFirstLevel,
        },
    };
    use circuit::CircuitOutput;
    use itertools::Itertools;
    use num::BigUint;
    use plonky2::{
        hash::hash_types::{HashOut, RichField},
        iop::{target::BoolTarget, witness::{PartialWitness, WitnessWrite}},
    };
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    #[serde(rename_all = "camelCase")]
    pub struct ValidatorProof {
        pub needs_change: bool,
        pub proof_key: String,
        pub public_inputs: CircuitOutput<ValidatorsCommitmentMapperFirstLevel>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ValidatorProof {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ValidatorProof",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "needsChange",
                    &self.needs_change,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proofKey",
                    &self.proof_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "publicInputs",
                    &self.public_inputs,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ValidatorProof {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "needsChange" => _serde::__private::Ok(__Field::__field0),
                            "proofKey" => _serde::__private::Ok(__Field::__field1),
                            "publicInputs" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"needsChange" => _serde::__private::Ok(__Field::__field0),
                            b"proofKey" => _serde::__private::Ok(__Field::__field1),
                            b"publicInputs" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ValidatorProof>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ValidatorProof;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ValidatorProof",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ValidatorProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ValidatorProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            CircuitOutput<ValidatorsCommitmentMapperFirstLevel>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ValidatorProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorProof {
                            needs_change: __field0,
                            proof_key: __field1,
                            public_inputs: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            CircuitOutput<ValidatorsCommitmentMapperFirstLevel>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "needsChange",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "proofKey",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publicInputs",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            CircuitOutput<ValidatorsCommitmentMapperFirstLevel>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("needsChange")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proofKey")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("publicInputs")?
                            }
                        };
                        _serde::__private::Ok(ValidatorProof {
                            needs_change: __field0,
                            proof_key: __field1,
                            public_inputs: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "needsChange",
                    "proofKey",
                    "publicInputs",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ValidatorProof",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ValidatorProof>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorProof {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ValidatorProof",
                "needs_change",
                &self.needs_change,
                "proof_key",
                &self.proof_key,
                "public_inputs",
                &&self.public_inputs,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorProof {
        #[inline]
        fn clone(&self) -> ValidatorProof {
            ValidatorProof {
                needs_change: ::core::clone::Clone::clone(&self.needs_change),
                proof_key: ::core::clone::Clone::clone(&self.proof_key),
                public_inputs: ::core::clone::Clone::clone(&self.public_inputs),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct BalanceProof<
        const VALIDATORS_COUNT: usize,
        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
    >
    where
        [(); VALIDATORS_COUNT / 4]:,
    {
        pub needs_change: bool,
        pub proof_key: String,
        pub public_inputs: CircuitOutput<
            WithdrawalCredentialsBalanceAggregatorFirstLevel<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >,
        >,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > _serde::Serialize
        for BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BalanceProof",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "needsChange",
                    &self.needs_change,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proofKey",
                    &self.proof_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "publicInputs",
                    &self.public_inputs,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<
            'de,
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > _serde::Deserialize<'de>
        for BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "needsChange" => _serde::__private::Ok(__Field::__field0),
                            "proofKey" => _serde::__private::Ok(__Field::__field1),
                            "publicInputs" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"needsChange" => _serde::__private::Ok(__Field::__field0),
                            b"proofKey" => _serde::__private::Ok(__Field::__field1),
                            b"publicInputs" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<
                    'de,
                    const VALIDATORS_COUNT: usize,
                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                >
                where
                    [(); VALIDATORS_COUNT / 4]:,
                {
                    marker: _serde::__private::PhantomData<
                        BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<
                    'de,
                    const VALIDATORS_COUNT: usize,
                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                > _serde::de::Visitor<'de>
                for __Visitor<'de, VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
                where
                    [(); VALIDATORS_COUNT / 4]:,
                {
                    type Value = BalanceProof<
                        VALIDATORS_COUNT,
                        WITHDRAWAL_CREDENTIALS_COUNT,
                    >;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BalanceProof",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BalanceProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BalanceProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            CircuitOutput<
                                WithdrawalCredentialsBalanceAggregatorFirstLevel<
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >,
                            >,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct BalanceProof with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BalanceProof {
                            needs_change: __field0,
                            proof_key: __field1,
                            public_inputs: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            CircuitOutput<
                                WithdrawalCredentialsBalanceAggregatorFirstLevel<
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >,
                            >,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "needsChange",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "proofKey",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publicInputs",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            CircuitOutput<
                                                WithdrawalCredentialsBalanceAggregatorFirstLevel<
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("needsChange")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proofKey")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("publicInputs")?
                            }
                        };
                        _serde::__private::Ok(BalanceProof {
                            needs_change: __field0,
                            proof_key: __field1,
                            public_inputs: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "needsChange",
                    "proofKey",
                    "publicInputs",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BalanceProof",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl<
        const VALIDATORS_COUNT: usize,
        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
    > ::core::fmt::Debug for BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
    where
        [(); VALIDATORS_COUNT / 4]:,
    {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "BalanceProof",
                "needs_change",
                &self.needs_change,
                "proof_key",
                &self.proof_key,
                "public_inputs",
                &&self.public_inputs,
            )
        }
    }
    #[automatically_derived]
    impl<
        const VALIDATORS_COUNT: usize,
        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
    > ::core::clone::Clone
    for BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
    where
        [(); VALIDATORS_COUNT / 4]:,
    {
        #[inline]
        fn clone(&self) -> BalanceProof<VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT> {
            BalanceProof {
                needs_change: ::core::clone::Clone::clone(&self.needs_change),
                proof_key: ::core::clone::Clone::clone(&self.proof_key),
                public_inputs: ::core::clone::Clone::clone(&self.public_inputs),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct BalanceAccumulatorProof {
        pub needs_change: bool,
        pub proof: Vec<u8>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BalanceAccumulatorProof {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BalanceAccumulatorProof",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "needsChange",
                    &self.needs_change,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proof",
                    &self.proof,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BalanceAccumulatorProof {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "needsChange" => _serde::__private::Ok(__Field::__field0),
                            "proof" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"needsChange" => _serde::__private::Ok(__Field::__field0),
                            b"proof" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<BalanceAccumulatorProof>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BalanceAccumulatorProof;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BalanceAccumulatorProof",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct BalanceAccumulatorProof with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct BalanceAccumulatorProof with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(BalanceAccumulatorProof {
                            needs_change: __field0,
                            proof: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "needsChange",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("needsChange")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proof")?
                            }
                        };
                        _serde::__private::Ok(BalanceAccumulatorProof {
                            needs_change: __field0,
                            proof: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["needsChange", "proof"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BalanceAccumulatorProof",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BalanceAccumulatorProof,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for BalanceAccumulatorProof {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "BalanceAccumulatorProof",
                "needs_change",
                &self.needs_change,
                "proof",
                &&self.proof,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BalanceAccumulatorProof {
        #[inline]
        fn clone(&self) -> BalanceAccumulatorProof {
            BalanceAccumulatorProof {
                needs_change: ::core::clone::Clone::clone(&self.needs_change),
                proof: ::core::clone::Clone::clone(&self.proof),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct FinalCircuitInput {
        #[serde(with = "bool_vec_as_int_vec")]
        pub state_root: Vec<bool>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub state_root_branch: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec")]
        pub block_root: Vec<bool>,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub slot: BigUint,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub slot_branch: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub withdrawal_credentials: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub balance_branch: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub validators_branch: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec")]
        pub validators_size_bits: Vec<bool>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FinalCircuitInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FinalCircuitInput",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "stateRoot",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<bool>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.state_root,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "stateRootBranch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.state_root_branch,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "blockRoot",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<bool>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.block_root,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "slot",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.slot,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "slotBranch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.slot_branch,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.withdrawal_credentials,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balanceBranch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.balance_branch,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorsBranch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.validators_branch,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorsSizeBits",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<bool>,),
                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.validators_size_bits,),
                            phantom: _serde::__private::PhantomData::<FinalCircuitInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FinalCircuitInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "stateRoot" => _serde::__private::Ok(__Field::__field0),
                            "stateRootBranch" => _serde::__private::Ok(__Field::__field1),
                            "blockRoot" => _serde::__private::Ok(__Field::__field2),
                            "slot" => _serde::__private::Ok(__Field::__field3),
                            "slotBranch" => _serde::__private::Ok(__Field::__field4),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "balanceBranch" => _serde::__private::Ok(__Field::__field6),
                            "validatorsBranch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "validatorsSizeBits" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"stateRoot" => _serde::__private::Ok(__Field::__field0),
                            b"stateRootBranch" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"blockRoot" => _serde::__private::Ok(__Field::__field2),
                            b"slot" => _serde::__private::Ok(__Field::__field3),
                            b"slotBranch" => _serde::__private::Ok(__Field::__field4),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"balanceBranch" => _serde::__private::Ok(__Field::__field6),
                            b"validatorsBranch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"validatorsSizeBits" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FinalCircuitInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FinalCircuitInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FinalCircuitInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<bool>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<bool>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<bool>,
                                phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct FinalCircuitInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FinalCircuitInput {
                            state_root: __field0,
                            state_root_branch: __field1,
                            block_root: __field2,
                            slot: __field3,
                            slot_branch: __field4,
                            withdrawal_credentials: __field5,
                            balance_branch: __field6,
                            validators_branch: __field7,
                            validators_size_bits: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<bool>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<bool>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Vec<bool>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "stateRoot",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<bool>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "stateRootBranch",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "blockRoot",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<bool>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("slot"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "slotBranch",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balanceBranch",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorsBranch",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorsSizeBits",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<bool>,
                                            phantom: _serde::__private::PhantomData<FinalCircuitInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "stateRoot",
                                    ),
                                );
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "stateRootBranch",
                                    ),
                                );
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "blockRoot",
                                    ),
                                );
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("slot"),
                                );
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "slotBranch",
                                    ),
                                );
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "withdrawalCredentials",
                                    ),
                                );
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "balanceBranch",
                                    ),
                                );
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "validatorsBranch",
                                    ),
                                );
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "validatorsSizeBits",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FinalCircuitInput {
                            state_root: __field0,
                            state_root_branch: __field1,
                            block_root: __field2,
                            slot: __field3,
                            slot_branch: __field4,
                            withdrawal_credentials: __field5,
                            balance_branch: __field6,
                            validators_branch: __field7,
                            validators_size_bits: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "stateRoot",
                    "stateRootBranch",
                    "blockRoot",
                    "slot",
                    "slotBranch",
                    "withdrawalCredentials",
                    "balanceBranch",
                    "validatorsBranch",
                    "validatorsSizeBits",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FinalCircuitInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FinalCircuitInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for FinalCircuitInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "state_root",
                "state_root_branch",
                "block_root",
                "slot",
                "slot_branch",
                "withdrawal_credentials",
                "balance_branch",
                "validators_branch",
                "validators_size_bits",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.state_root,
                &self.state_root_branch,
                &self.block_root,
                &self.slot,
                &self.slot_branch,
                &self.withdrawal_credentials,
                &self.balance_branch,
                &self.validators_branch,
                &&self.validators_size_bits,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "FinalCircuitInput",
                names,
                values,
            )
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct FinalProof {
        pub needs_change: bool,
        pub block_root: String,
        pub withdrawal_credentials: Vec<String>,
        pub balance_sum: u64,
        pub number_of_non_activated_validators: u64,
        pub number_of_active_validators: u64,
        pub number_of_exitted_validators: u64,
        pub proof: Vec<u8>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FinalProof {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FinalProof",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "needsChange",
                    &self.needs_change,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "blockRoot",
                    &self.block_root,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    &self.withdrawal_credentials,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balanceSum",
                    &self.balance_sum,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "numberOfNonActivatedValidators",
                    &self.number_of_non_activated_validators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "numberOfActiveValidators",
                    &self.number_of_active_validators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "numberOfExittedValidators",
                    &self.number_of_exitted_validators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proof",
                    &self.proof,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FinalProof {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "needsChange" => _serde::__private::Ok(__Field::__field0),
                            "blockRoot" => _serde::__private::Ok(__Field::__field1),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "balanceSum" => _serde::__private::Ok(__Field::__field3),
                            "numberOfNonActivatedValidators" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "numberOfActiveValidators" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "numberOfExittedValidators" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "proof" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"needsChange" => _serde::__private::Ok(__Field::__field0),
                            b"blockRoot" => _serde::__private::Ok(__Field::__field1),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"balanceSum" => _serde::__private::Ok(__Field::__field3),
                            b"numberOfNonActivatedValidators" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"numberOfActiveValidators" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"numberOfExittedValidators" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"proof" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FinalProof>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FinalProof;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FinalProof",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct FinalProof with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FinalProof {
                            needs_change: __field0,
                            block_root: __field1,
                            withdrawal_credentials: __field2,
                            balance_sum: __field3,
                            number_of_non_activated_validators: __field4,
                            number_of_active_validators: __field5,
                            number_of_exitted_validators: __field6,
                            proof: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "needsChange",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "blockRoot",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balanceSum",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "numberOfNonActivatedValidators",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "numberOfActiveValidators",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "numberOfExittedValidators",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("needsChange")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("blockRoot")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "withdrawalCredentials",
                                )?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("balanceSum")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "numberOfNonActivatedValidators",
                                )?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "numberOfActiveValidators",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "numberOfExittedValidators",
                                )?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proof")?
                            }
                        };
                        _serde::__private::Ok(FinalProof {
                            needs_change: __field0,
                            block_root: __field1,
                            withdrawal_credentials: __field2,
                            balance_sum: __field3,
                            number_of_non_activated_validators: __field4,
                            number_of_active_validators: __field5,
                            number_of_exitted_validators: __field6,
                            proof: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "needsChange",
                    "blockRoot",
                    "withdrawalCredentials",
                    "balanceSum",
                    "numberOfNonActivatedValidators",
                    "numberOfActiveValidators",
                    "numberOfExittedValidators",
                    "proof",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FinalProof",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FinalProof>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for FinalProof {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "needs_change",
                "block_root",
                "withdrawal_credentials",
                "balance_sum",
                "number_of_non_activated_validators",
                "number_of_active_validators",
                "number_of_exitted_validators",
                "proof",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.needs_change,
                &self.block_root,
                &self.withdrawal_credentials,
                &self.balance_sum,
                &self.number_of_non_activated_validators,
                &self.number_of_active_validators,
                &self.number_of_exitted_validators,
                &&self.proof,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "FinalProof",
                names,
                values,
            )
        }
    }
    pub fn set_boolean_pw_values<F: RichField>(
        pw: &mut PartialWitness<F>,
        target: &[BoolTarget],
        source: &Vec<bool>,
    ) {
        for i in 0..target.len() {
            pw.set_bool_target(target[i], source[i]);
        }
    }
    pub trait SetPWValues<F: RichField, T> {
        fn set_pw_values(&self, pw: &mut PartialWitness<F>, source: &T);
    }
    impl<F: RichField> SetPWValues<F, ValidatorInput> for ValidatorTarget {
        fn set_pw_values(&self, pw: &mut PartialWitness<F>, source: &ValidatorInput) {
            pw.set_bytes_array(&self.pubkey, &hex::decode(&source.pubkey).unwrap());
            pw.set_bytes_array(
                &self.withdrawal_credentials,
                &hex::decode(&source.withdrawal_credentials).unwrap(),
            );
            pw.set_biguint_target(&self.effective_balance, &source.effective_balance);
            pw.set_bool_target(self.slashed, source.slashed == 1);
            pw.set_biguint_target(
                &self.activation_eligibility_epoch,
                &source.activation_eligibility_epoch,
            );
            pw.set_biguint_target(&self.activation_epoch, &source.activation_epoch);
            pw.set_biguint_target(&self.exit_epoch, &source.exit_epoch);
            pw.set_biguint_target(&self.withdrawable_epoch, &source.withdrawable_epoch);
        }
    }
    impl<
        F: RichField,
        const VALIDATORS_COUNT: usize,
        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
    > SetPWValues<F, ValidatorBalancesInput>
    for ValidatorBalanceVerificationTargets<
        VALIDATORS_COUNT,
        WITHDRAWAL_CREDENTIALS_COUNT,
    >
    where
        [(); VALIDATORS_COUNT / 4]:,
    {
        fn set_pw_values(
            &self,
            pw: &mut PartialWitness<F>,
            source: &ValidatorBalancesInput,
        ) {
            for i in 0..VALIDATORS_COUNT / 4 {
                set_boolean_pw_values(pw, &self.balances_leaves[i], &source.balances[i]);
            }
            for i in 0..VALIDATORS_COUNT {
                self.validators[i].set_pw_values(pw, &source.validators[i]);
            }
            for i in 0..WITHDRAWAL_CREDENTIALS_COUNT {
                set_boolean_pw_values(
                    pw,
                    &self.withdrawal_credentials[i],
                    &source.withdrawal_credentials[i],
                );
            }
            set_boolean_pw_values(
                pw,
                &self.non_zero_validator_leaves_mask,
                &source.validator_is_zero,
            );
            pw.set_biguint_target(&self.current_epoch, &source.current_epoch);
        }
    }
    impl<F: RichField> SetPWValues<F, DepositDataInput> for DepositDataTarget {
        fn set_pw_values(&self, pw: &mut PartialWitness<F>, source: &DepositDataInput) {
            pw.set_bytes_array(&self.pubkey, &hex::decode(&source.pubkey).unwrap());
            pw.set_bytes_array(
                &self.withdrawal_credentials,
                &hex::decode(&source.withdrawal_credentials).unwrap(),
            );
            pw.set_biguint_target(&self.amount, &BigUint::from(source.amount));
            pw.set_bytes_array(
                &self.signature,
                &hex::decode(&source.signature).unwrap(),
            );
        }
    }
    impl<F: RichField> SetPWValues<F, ValidatorBalanceAccumulatorInput>
    for ValidatorBalanceVerificationAccumulatorTargets {
        fn set_pw_values(
            &self,
            pw: &mut PartialWitness<F>,
            source: &ValidatorBalanceAccumulatorInput,
        ) {
            for i in 0..source.balances_leaves.len() {
                pw.set_bytes_array(
                    &self.balances_leaves[i],
                    &hex::decode(&source.balances_leaves[i]).unwrap(),
                );
            }
            pw.set_bytes_array(
                &self.balances_root,
                &hex::decode(&source.balances_root).unwrap(),
            );
            for i in 0..source.validator_is_not_zero.len() {
                pw.set_bool_target(
                    self.non_zero_validator_leaves_mask[i],
                    source.validator_is_not_zero[i],
                );
            }
            for i in 0..source.balances_proofs.len() {
                for j in 0..source.balances_proofs[i].len() {
                    pw.set_bytes_array(
                        &self.balances_proofs[i][j],
                        &hex::decode(&source.balances_proofs[i][j]).unwrap(),
                    );
                }
            }
            for i in 0..source.validators.len() {
                self.validators[i].set_pw_values(pw, &source.validators[i]);
            }
            for i in 0..source.validator_indices.len() {
                pw.set_biguint_target(
                    &self.validator_indices[i],
                    &BigUint::from(source.validator_indices[i]),
                );
            }
            pw.set_biguint_target(
                &self.current_epoch,
                &BigUint::from(source.current_epoch),
            );
            for i in 0..source.deposits_data.len() {
                self.deposits_data[i].set_pw_values(pw, &source.deposits_data[i]);
            }
            let validators_poseidon_root_targets = HashOut::from_vec(
                source
                    .validators_poseidon_root
                    .iter()
                    .map(|&number| F::from_canonical_u64(number))
                    .collect_vec(),
            );
            pw.set_hash_target(
                self.validators_poseidon_root,
                validators_poseidon_root_targets,
            );
        }
    }
    impl<F: RichField> SetPWValues<F, ValidatorShaInput> for ValidatorShaTargets {
        fn set_pw_values(&self, pw: &mut PartialWitness<F>, source: &ValidatorShaInput) {
            pw.set_bytes_array(&self.pubkey, &hex::decode(&source.pubkey).unwrap());
            pw.set_bytes_array(
                &self.withdrawal_credentials,
                &hex::decode(&source.withdrawal_credentials).unwrap(),
            );
            pw.set_bytes_array(
                &self.effective_balance,
                &hex::decode(&source.effective_balance).unwrap(),
            );
            pw.set_bytes_array(&self.slashed, &hex::decode(&source.slashed).unwrap());
            pw.set_bytes_array(
                &self.activation_eligibility_epoch,
                &hex::decode(&source.activation_eligibility_epoch).unwrap(),
            );
            pw.set_bytes_array(
                &self.activation_epoch,
                &hex::decode(&source.activation_epoch).unwrap(),
            );
            pw.set_bytes_array(
                &self.exit_epoch,
                &hex::decode(&source.exit_epoch).unwrap(),
            );
            pw.set_bytes_array(
                &self.withdrawable_epoch,
                &hex::decode(&source.withdrawable_epoch).unwrap(),
            );
        }
    }
    impl<F: RichField, const N: usize> SetPWValues<F, FinalCircuitInput>
    for FinalCircuitTargets<N> {
        fn set_pw_values(&self, pw: &mut PartialWitness<F>, source: &FinalCircuitInput) {
            set_boolean_pw_values(pw, &self.state_root, &source.state_root);
            for i in 0..source.state_root_branch.len() {
                set_boolean_pw_values(
                    pw,
                    &self.state_root_branch[i],
                    &source.state_root_branch[i],
                );
            }
            set_boolean_pw_values(pw, &self.block_root, &source.block_root);
            pw.set_biguint_target(&self.slot, &source.slot);
            for i in 0..source.slot_branch.len() {
                set_boolean_pw_values(pw, &self.slot_branch[i], &source.slot_branch[i]);
            }
            for i in 0..N {
                set_boolean_pw_values(
                    pw,
                    &self.withdrawal_credentials[i],
                    &source.withdrawal_credentials[i],
                );
            }
            for i in 0..source.balance_branch.len() {
                set_boolean_pw_values(
                    pw,
                    &self.balance_branch[i],
                    &source.balance_branch[i],
                );
            }
            for i in 0..source.validators_branch.len() {
                set_boolean_pw_values(
                    pw,
                    &self.validators_branch[i],
                    &source.validators_branch[i],
                );
            }
            set_boolean_pw_values(
                pw,
                &self.validator_size_bits,
                &source.validators_size_bits,
            );
        }
    }
    pub fn from_str<'de, D>(deserializer: D) -> Result<Vec<u64>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s: Vec<String> = Vec::deserialize(deserializer)?;
        s.into_iter()
            .map(|str_val| str_val.parse::<u64>().map_err(serde::de::Error::custom))
            .collect()
    }
    pub fn to_string<S>(x: &Vec<u64>, s: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let string_vec: Vec<String> = x.iter().map(|&num| num.to_string()).collect();
        string_vec.serialize(s)
    }
    #[serde(rename_all = "camelCase")]
    pub struct ValidatorInput {
        pub pubkey: String,
        pub withdrawal_credentials: String,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub effective_balance: BigUint,
        pub slashed: u64,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub activation_eligibility_epoch: BigUint,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub activation_epoch: BigUint,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub exit_epoch: BigUint,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub withdrawable_epoch: BigUint,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ValidatorInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ValidatorInput",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pubkey",
                    &self.pubkey,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    &self.withdrawal_credentials,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "effectiveBalance",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.effective_balance,),
                            phantom: _serde::__private::PhantomData::<ValidatorInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "slashed",
                    &self.slashed,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "activationEligibilityEpoch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.activation_eligibility_epoch,),
                            phantom: _serde::__private::PhantomData::<ValidatorInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "activationEpoch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.activation_epoch,),
                            phantom: _serde::__private::PhantomData::<ValidatorInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "exitEpoch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.exit_epoch,),
                            phantom: _serde::__private::PhantomData::<ValidatorInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawableEpoch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.withdrawable_epoch,),
                            phantom: _serde::__private::PhantomData::<ValidatorInput>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ValidatorInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "pubkey" => _serde::__private::Ok(__Field::__field0),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "effectiveBalance" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "slashed" => _serde::__private::Ok(__Field::__field3),
                            "activationEligibilityEpoch" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "activationEpoch" => _serde::__private::Ok(__Field::__field5),
                            "exitEpoch" => _serde::__private::Ok(__Field::__field6),
                            "withdrawableEpoch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"pubkey" => _serde::__private::Ok(__Field::__field0),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"effectiveBalance" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"slashed" => _serde::__private::Ok(__Field::__field3),
                            b"activationEligibilityEpoch" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"activationEpoch" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"exitEpoch" => _serde::__private::Ok(__Field::__field6),
                            b"withdrawableEpoch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ValidatorInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ValidatorInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ValidatorInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<ValidatorInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<ValidatorInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<ValidatorInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<ValidatorInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<ValidatorInput>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ValidatorInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            effective_balance: __field2,
                            slashed: __field3,
                            activation_eligibility_epoch: __field4,
                            activation_epoch: __field5,
                            exit_epoch: __field6,
                            withdrawable_epoch: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<BigUint> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "effectiveBalance",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "slashed",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "activationEligibilityEpoch",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "activationEpoch",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "exitEpoch",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawableEpoch",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<ValidatorInput>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pubkey")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "withdrawalCredentials",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "effectiveBalance",
                                    ),
                                );
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("slashed")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "activationEligibilityEpoch",
                                    ),
                                );
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "activationEpoch",
                                    ),
                                );
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "exitEpoch",
                                    ),
                                );
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "withdrawableEpoch",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            effective_balance: __field2,
                            slashed: __field3,
                            activation_eligibility_epoch: __field4,
                            activation_epoch: __field5,
                            exit_epoch: __field6,
                            withdrawable_epoch: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "pubkey",
                    "withdrawalCredentials",
                    "effectiveBalance",
                    "slashed",
                    "activationEligibilityEpoch",
                    "activationEpoch",
                    "exitEpoch",
                    "withdrawableEpoch",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ValidatorInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ValidatorInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "pubkey",
                "withdrawal_credentials",
                "effective_balance",
                "slashed",
                "activation_eligibility_epoch",
                "activation_epoch",
                "exit_epoch",
                "withdrawable_epoch",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.pubkey,
                &self.withdrawal_credentials,
                &self.effective_balance,
                &self.slashed,
                &self.activation_eligibility_epoch,
                &self.activation_epoch,
                &self.exit_epoch,
                &&self.withdrawable_epoch,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ValidatorInput",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ValidatorInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ValidatorInput {
        #[inline]
        fn eq(&self, other: &ValidatorInput) -> bool {
            self.pubkey == other.pubkey
                && self.withdrawal_credentials == other.withdrawal_credentials
                && self.effective_balance == other.effective_balance
                && self.slashed == other.slashed
                && self.activation_eligibility_epoch
                    == other.activation_eligibility_epoch
                && self.activation_epoch == other.activation_epoch
                && self.exit_epoch == other.exit_epoch
                && self.withdrawable_epoch == other.withdrawable_epoch
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorInput {
        #[inline]
        fn clone(&self) -> ValidatorInput {
            ValidatorInput {
                pubkey: ::core::clone::Clone::clone(&self.pubkey),
                withdrawal_credentials: ::core::clone::Clone::clone(
                    &self.withdrawal_credentials,
                ),
                effective_balance: ::core::clone::Clone::clone(&self.effective_balance),
                slashed: ::core::clone::Clone::clone(&self.slashed),
                activation_eligibility_epoch: ::core::clone::Clone::clone(
                    &self.activation_eligibility_epoch,
                ),
                activation_epoch: ::core::clone::Clone::clone(&self.activation_epoch),
                exit_epoch: ::core::clone::Clone::clone(&self.exit_epoch),
                withdrawable_epoch: ::core::clone::Clone::clone(&self.withdrawable_epoch),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct ValidatorBalancesInput {
        pub validators: Vec<ValidatorInput>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub balances: Vec<Vec<bool>>,
        #[serde(with = "bool_vec_as_int_vec_nested")]
        pub withdrawal_credentials: Vec<Vec<bool>>,
        #[serde(serialize_with = "biguint_to_str", deserialize_with = "parse_biguint")]
        pub current_epoch: BigUint,
        #[serde(with = "bool_vec_as_int_vec")]
        pub validator_is_zero: Vec<bool>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ValidatorBalancesInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ValidatorBalancesInput",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validators",
                    &self.validators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balances",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<
                                ValidatorBalancesInput,
                            >,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.balances,),
                            phantom: _serde::__private::PhantomData::<
                                ValidatorBalancesInput,
                            >,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<Vec<bool>>,),
                            phantom: _serde::__private::PhantomData<
                                ValidatorBalancesInput,
                            >,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec_nested::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.withdrawal_credentials,),
                            phantom: _serde::__private::PhantomData::<
                                ValidatorBalancesInput,
                            >,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currentEpoch",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a BigUint,),
                            phantom: _serde::__private::PhantomData<
                                ValidatorBalancesInput,
                            >,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                biguint_to_str(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.current_epoch,),
                            phantom: _serde::__private::PhantomData::<
                                ValidatorBalancesInput,
                            >,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorIsZero",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<bool>,),
                            phantom: _serde::__private::PhantomData<
                                ValidatorBalancesInput,
                            >,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.validator_is_zero,),
                            phantom: _serde::__private::PhantomData::<
                                ValidatorBalancesInput,
                            >,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ValidatorBalancesInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "validators" => _serde::__private::Ok(__Field::__field0),
                            "balances" => _serde::__private::Ok(__Field::__field1),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "currentEpoch" => _serde::__private::Ok(__Field::__field3),
                            "validatorIsZero" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"validators" => _serde::__private::Ok(__Field::__field0),
                            b"balances" => _serde::__private::Ok(__Field::__field1),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"currentEpoch" => _serde::__private::Ok(__Field::__field3),
                            b"validatorIsZero" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ValidatorBalancesInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ValidatorBalancesInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ValidatorBalancesInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<ValidatorInput>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ValidatorBalancesInput with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalancesInput,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ValidatorBalancesInput with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<Vec<bool>>,
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalancesInput,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec_nested::deserialize(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ValidatorBalancesInput with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: BigUint,
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalancesInput,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_biguint(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ValidatorBalancesInput with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<bool>,
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalancesInput,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ValidatorBalancesInput with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorBalancesInput {
                            validators: __field0,
                            balances: __field1,
                            withdrawal_credentials: __field2,
                            current_epoch: __field3,
                            validator_is_zero: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Vec<ValidatorInput>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<Vec<bool>>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<BigUint> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Vec<bool>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validators",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ValidatorInput>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balances",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<
                                                ValidatorBalancesInput,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<Vec<bool>>,
                                            phantom: _serde::__private::PhantomData<
                                                ValidatorBalancesInput,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec_nested::deserialize(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currentEpoch",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: BigUint,
                                            phantom: _serde::__private::PhantomData<
                                                ValidatorBalancesInput,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_biguint(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorIsZero",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<bool>,
                                            phantom: _serde::__private::PhantomData<
                                                ValidatorBalancesInput,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("validators")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("balances"),
                                );
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "withdrawalCredentials",
                                    ),
                                );
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "currentEpoch",
                                    ),
                                );
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "validatorIsZero",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorBalancesInput {
                            validators: __field0,
                            balances: __field1,
                            withdrawal_credentials: __field2,
                            current_epoch: __field3,
                            validator_is_zero: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "validators",
                    "balances",
                    "withdrawalCredentials",
                    "currentEpoch",
                    "validatorIsZero",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ValidatorBalancesInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ValidatorBalancesInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorBalancesInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ValidatorBalancesInput",
                "validators",
                &self.validators,
                "balances",
                &self.balances,
                "withdrawal_credentials",
                &self.withdrawal_credentials,
                "current_epoch",
                &self.current_epoch,
                "validator_is_zero",
                &&self.validator_is_zero,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ValidatorBalancesInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ValidatorBalancesInput {
        #[inline]
        fn eq(&self, other: &ValidatorBalancesInput) -> bool {
            self.validators == other.validators && self.balances == other.balances
                && self.withdrawal_credentials == other.withdrawal_credentials
                && self.current_epoch == other.current_epoch
                && self.validator_is_zero == other.validator_is_zero
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorBalancesInput {
        #[inline]
        fn clone(&self) -> ValidatorBalancesInput {
            ValidatorBalancesInput {
                validators: ::core::clone::Clone::clone(&self.validators),
                balances: ::core::clone::Clone::clone(&self.balances),
                withdrawal_credentials: ::core::clone::Clone::clone(
                    &self.withdrawal_credentials,
                ),
                current_epoch: ::core::clone::Clone::clone(&self.current_epoch),
                validator_is_zero: ::core::clone::Clone::clone(&self.validator_is_zero),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct ValidatorBalanceAccumulatorInput {
        pub balances_root: String,
        pub balances_leaves: Vec<String>,
        pub balances_proofs: Vec<Vec<String>>,
        pub validator_indices: Vec<u64>,
        pub validators: Vec<ValidatorInput>,
        #[serde(with = "bool_vec_as_int_vec")]
        pub validator_is_not_zero: Vec<bool>,
        pub current_epoch: u64,
        pub deposits_data: Vec<DepositDataInput>,
        pub validators_poseidon_root: Vec<u64>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ValidatorBalanceAccumulatorInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ValidatorBalanceAccumulatorInput",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balancesRoot",
                    &self.balances_root,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balancesLeaves",
                    &self.balances_leaves,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "balancesProofs",
                    &self.balances_proofs,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorIndices",
                    &self.validator_indices,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validators",
                    &self.validators,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorIsNotZero",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Vec<bool>,),
                            phantom: _serde::__private::PhantomData<
                                ValidatorBalanceAccumulatorInput,
                            >,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                bool_vec_as_int_vec::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.validator_is_not_zero,),
                            phantom: _serde::__private::PhantomData::<
                                ValidatorBalanceAccumulatorInput,
                            >,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "currentEpoch",
                    &self.current_epoch,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "depositsData",
                    &self.deposits_data,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "validatorsPoseidonRoot",
                    &self.validators_poseidon_root,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ValidatorBalanceAccumulatorInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "balancesRoot" => _serde::__private::Ok(__Field::__field0),
                            "balancesLeaves" => _serde::__private::Ok(__Field::__field1),
                            "balancesProofs" => _serde::__private::Ok(__Field::__field2),
                            "validatorIndices" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "validators" => _serde::__private::Ok(__Field::__field4),
                            "validatorIsNotZero" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "currentEpoch" => _serde::__private::Ok(__Field::__field6),
                            "depositsData" => _serde::__private::Ok(__Field::__field7),
                            "validatorsPoseidonRoot" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"balancesRoot" => _serde::__private::Ok(__Field::__field0),
                            b"balancesLeaves" => _serde::__private::Ok(__Field::__field1),
                            b"balancesProofs" => _serde::__private::Ok(__Field::__field2),
                            b"validatorIndices" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"validators" => _serde::__private::Ok(__Field::__field4),
                            b"validatorIsNotZero" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"currentEpoch" => _serde::__private::Ok(__Field::__field6),
                            b"depositsData" => _serde::__private::Ok(__Field::__field7),
                            b"validatorsPoseidonRoot" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        ValidatorBalanceAccumulatorInput,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ValidatorBalanceAccumulatorInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ValidatorBalanceAccumulatorInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<Vec<String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<ValidatorInput>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Vec<bool>,
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceAccumulatorInput,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<DepositDataInput>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Vec<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ValidatorBalanceAccumulatorInput with 9 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorBalanceAccumulatorInput {
                            balances_root: __field0,
                            balances_leaves: __field1,
                            balances_proofs: __field2,
                            validator_indices: __field3,
                            validators: __field4,
                            validator_is_not_zero: __field5,
                            current_epoch: __field6,
                            deposits_data: __field7,
                            validators_poseidon_root: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<Vec<String>>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Vec<u64>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            Vec<ValidatorInput>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<bool>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<
                            Vec<DepositDataInput>,
                        > = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Vec<u64>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balancesRoot",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balancesLeaves",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "balancesProofs",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Vec<String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorIndices",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u64>>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validators",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ValidatorInput>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorIsNotZero",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Vec<bool>,
                                            phantom: _serde::__private::PhantomData<
                                                ValidatorBalanceAccumulatorInput,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: bool_vec_as_int_vec::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "currentEpoch",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "depositsData",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<DepositDataInput>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "validatorsPoseidonRoot",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u64>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("balancesRoot")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("balancesLeaves")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("balancesProofs")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("validatorIndices")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("validators")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "validatorIsNotZero",
                                    ),
                                );
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("currentEpoch")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("depositsData")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "validatorsPoseidonRoot",
                                )?
                            }
                        };
                        _serde::__private::Ok(ValidatorBalanceAccumulatorInput {
                            balances_root: __field0,
                            balances_leaves: __field1,
                            balances_proofs: __field2,
                            validator_indices: __field3,
                            validators: __field4,
                            validator_is_not_zero: __field5,
                            current_epoch: __field6,
                            deposits_data: __field7,
                            validators_poseidon_root: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "balancesRoot",
                    "balancesLeaves",
                    "balancesProofs",
                    "validatorIndices",
                    "validators",
                    "validatorIsNotZero",
                    "currentEpoch",
                    "depositsData",
                    "validatorsPoseidonRoot",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ValidatorBalanceAccumulatorInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ValidatorBalanceAccumulatorInput,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorBalanceAccumulatorInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "balances_root",
                "balances_leaves",
                "balances_proofs",
                "validator_indices",
                "validators",
                "validator_is_not_zero",
                "current_epoch",
                "deposits_data",
                "validators_poseidon_root",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.balances_root,
                &self.balances_leaves,
                &self.balances_proofs,
                &self.validator_indices,
                &self.validators,
                &self.validator_is_not_zero,
                &self.current_epoch,
                &self.deposits_data,
                &&self.validators_poseidon_root,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ValidatorBalanceAccumulatorInput",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ValidatorBalanceAccumulatorInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ValidatorBalanceAccumulatorInput {
        #[inline]
        fn eq(&self, other: &ValidatorBalanceAccumulatorInput) -> bool {
            self.balances_root == other.balances_root
                && self.balances_leaves == other.balances_leaves
                && self.balances_proofs == other.balances_proofs
                && self.validator_indices == other.validator_indices
                && self.validators == other.validators
                && self.validator_is_not_zero == other.validator_is_not_zero
                && self.current_epoch == other.current_epoch
                && self.deposits_data == other.deposits_data
                && self.validators_poseidon_root == other.validators_poseidon_root
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorBalanceAccumulatorInput {
        #[inline]
        fn clone(&self) -> ValidatorBalanceAccumulatorInput {
            ValidatorBalanceAccumulatorInput {
                balances_root: ::core::clone::Clone::clone(&self.balances_root),
                balances_leaves: ::core::clone::Clone::clone(&self.balances_leaves),
                balances_proofs: ::core::clone::Clone::clone(&self.balances_proofs),
                validator_indices: ::core::clone::Clone::clone(&self.validator_indices),
                validators: ::core::clone::Clone::clone(&self.validators),
                validator_is_not_zero: ::core::clone::Clone::clone(
                    &self.validator_is_not_zero,
                ),
                current_epoch: ::core::clone::Clone::clone(&self.current_epoch),
                deposits_data: ::core::clone::Clone::clone(&self.deposits_data),
                validators_poseidon_root: ::core::clone::Clone::clone(
                    &self.validators_poseidon_root,
                ),
            }
        }
    }
    #[serde(rename_all = "camelCase")]
    pub struct DepositDataInput {
        pub pubkey: String,
        pub withdrawal_credentials: String,
        pub amount: u64,
        pub signature: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DepositDataInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DepositDataInput",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pubkey",
                    &self.pubkey,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    &self.withdrawal_credentials,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "signature",
                    &self.signature,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DepositDataInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "pubkey" => _serde::__private::Ok(__Field::__field0),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "amount" => _serde::__private::Ok(__Field::__field2),
                            "signature" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"pubkey" => _serde::__private::Ok(__Field::__field0),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"amount" => _serde::__private::Ok(__Field::__field2),
                            b"signature" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DepositDataInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DepositDataInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DepositDataInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DepositDataInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DepositDataInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DepositDataInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct DepositDataInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DepositDataInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            amount: __field2,
                            signature: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "signature",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pubkey")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "withdrawalCredentials",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("signature")?
                            }
                        };
                        _serde::__private::Ok(DepositDataInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            amount: __field2,
                            signature: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "pubkey",
                    "withdrawalCredentials",
                    "amount",
                    "signature",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DepositDataInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DepositDataInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for DepositDataInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "DepositDataInput",
                "pubkey",
                &self.pubkey,
                "withdrawal_credentials",
                &self.withdrawal_credentials,
                "amount",
                &self.amount,
                "signature",
                &&self.signature,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DepositDataInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DepositDataInput {
        #[inline]
        fn eq(&self, other: &DepositDataInput) -> bool {
            self.pubkey == other.pubkey
                && self.withdrawal_credentials == other.withdrawal_credentials
                && self.amount == other.amount && self.signature == other.signature
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DepositDataInput {
        #[inline]
        fn clone(&self) -> DepositDataInput {
            DepositDataInput {
                pubkey: ::core::clone::Clone::clone(&self.pubkey),
                withdrawal_credentials: ::core::clone::Clone::clone(
                    &self.withdrawal_credentials,
                ),
                amount: ::core::clone::Clone::clone(&self.amount),
                signature: ::core::clone::Clone::clone(&self.signature),
            }
        }
    }
}
pub mod common_targets {
    use circuit_derive::{CircuitTarget, SerdeCircuitTarget};
    use plonky2::{
        iop::target::BoolTarget,
        plonk::{circuit_data::VerifierCircuitTarget, proof::ProofWithPublicInputsTarget},
    };
    pub type Sha256Target = [BoolTarget; 256];
    pub type SSZLeafTarget = [BoolTarget; 256];
    pub struct BasicRecursiveInnerCircuitTarget {
        pub proof1: ProofWithPublicInputsTarget<2>,
        pub proof2: ProofWithPublicInputsTarget<2>,
        pub verifier_circuit_target: VerifierCircuitTarget,
    }
    pub struct BasicRecursiveInnerCircuitTargetPublicInputs {}
    #[automatically_derived]
    impl ::core::fmt::Debug for BasicRecursiveInnerCircuitTargetPublicInputs {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                "BasicRecursiveInnerCircuitTargetPublicInputs",
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BasicRecursiveInnerCircuitTargetPublicInputs {
        #[inline]
        fn clone(&self) -> BasicRecursiveInnerCircuitTargetPublicInputs {
            BasicRecursiveInnerCircuitTargetPublicInputs {
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BasicRecursiveInnerCircuitTargetPublicInputs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BasicRecursiveInnerCircuitTargetPublicInputs",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de>
        for BasicRecursiveInnerCircuitTargetPublicInputs {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        BasicRecursiveInnerCircuitTargetPublicInputs,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BasicRecursiveInnerCircuitTargetPublicInputs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BasicRecursiveInnerCircuitTargetPublicInputs",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(BasicRecursiveInnerCircuitTargetPublicInputs {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(BasicRecursiveInnerCircuitTargetPublicInputs {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BasicRecursiveInnerCircuitTargetPublicInputs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BasicRecursiveInnerCircuitTargetPublicInputs,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct BasicRecursiveInnerCircuitTargetPublicInputsTarget {}
    impl BasicRecursiveInnerCircuitTargetPublicInputsTarget {
        pub fn register_public_inputs<
            F: plonky2::hash::hash_types::RichField
                + plonky2::field::extension::Extendable<D>,
            const D: usize,
        >(&self, builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>) {}
    }
    impl std::convert::From<BasicRecursiveInnerCircuitTarget>
    for BasicRecursiveInnerCircuitTargetPublicInputsTarget {
        fn from(
            value: BasicRecursiveInnerCircuitTarget,
        ) -> BasicRecursiveInnerCircuitTargetPublicInputsTarget {
            BasicRecursiveInnerCircuitTargetPublicInputsTarget {
            }
        }
    }
    impl circuit::TargetsWithPublicInputs for BasicRecursiveInnerCircuitTarget {
        type PublicInputs = BasicRecursiveInnerCircuitTargetPublicInputs;
        #[allow(unused_variables)]
        fn read_public_inputs<F: plonky2::hash::hash_types::RichField>(
            public_inputs: &[F],
        ) -> Self::PublicInputs {
            let mut reader = circuit::PublicInputsFieldReader::new(public_inputs);
            BasicRecursiveInnerCircuitTargetPublicInputs {
            }
        }
        type PublicInputsTarget = BasicRecursiveInnerCircuitTargetPublicInputsTarget;
        #[allow(unused_variables)]
        fn read_public_inputs_target(
            public_inputs: &[plonky2::iop::target::Target],
        ) -> Self::PublicInputsTarget {
            let mut reader = circuit::PublicInputsTargetReader::new(public_inputs);
            BasicRecursiveInnerCircuitTargetPublicInputsTarget {
            }
        }
        #[allow(unused_variables)]
        fn register_public_inputs<
            F: plonky2::hash::hash_types::RichField
                + plonky2::field::extension::Extendable<D>,
            const D: usize,
        >(&self, builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>) {}
    }
    pub struct BasicRecursiveInnerCircuitTargetWitnessInput {}
    #[automatically_derived]
    impl ::core::fmt::Debug for BasicRecursiveInnerCircuitTargetWitnessInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                "BasicRecursiveInnerCircuitTargetWitnessInput",
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BasicRecursiveInnerCircuitTargetWitnessInput {
        #[inline]
        fn clone(&self) -> BasicRecursiveInnerCircuitTargetWitnessInput {
            BasicRecursiveInnerCircuitTargetWitnessInput {
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BasicRecursiveInnerCircuitTargetWitnessInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "BasicRecursiveInnerCircuitTargetWitnessInput",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de>
        for BasicRecursiveInnerCircuitTargetWitnessInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        BasicRecursiveInnerCircuitTargetWitnessInput,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BasicRecursiveInnerCircuitTargetWitnessInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct BasicRecursiveInnerCircuitTargetWitnessInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(BasicRecursiveInnerCircuitTargetWitnessInput {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(BasicRecursiveInnerCircuitTargetWitnessInput {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BasicRecursiveInnerCircuitTargetWitnessInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            BasicRecursiveInnerCircuitTargetWitnessInput,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl<F: plonky2::hash::hash_types::RichField> circuit::SetWitness<F>
    for BasicRecursiveInnerCircuitTarget {
        type Input = BasicRecursiveInnerCircuitTargetWitnessInput;
        #[allow(unused_variables)]
        fn set_witness(
            &self,
            witness: &mut plonky2::iop::witness::PartialWitness<F>,
            input: &Self::Input,
        ) {}
    }
    pub struct BasicRecursiveInnerCircuitTargetCircuitInputTarget {}
    impl circuit::AddVirtualTarget
    for BasicRecursiveInnerCircuitTargetCircuitInputTarget {
        fn add_virtual_target<
            F: plonky2::hash::hash_types::RichField
                + plonky2::field::extension::Extendable<D>,
            const D: usize,
        >(builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>) -> Self {
            BasicRecursiveInnerCircuitTargetCircuitInputTarget {
            }
        }
    }
    impl circuit::ReadableCircuitInputTarget for BasicRecursiveInnerCircuitTarget {
        type CircuitInputTarget = BasicRecursiveInnerCircuitTargetCircuitInputTarget;
        fn read_circuit_input_target<
            F: plonky2::hash::hash_types::RichField
                + plonky2::field::extension::Extendable<D>,
            const D: usize,
        >(
            builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
        ) -> Self::CircuitInputTarget {
            <Self::CircuitInputTarget as circuit::AddVirtualTarget>::add_virtual_target(
                builder,
            )
        }
    }
    impl circuit::SerdeCircuitTarget for BasicRecursiveInnerCircuitTarget {
        fn serialize(&self) -> plonky2::util::serialization::IoResult<Vec<u8>> {
            let mut buffer: Vec<u8> = Vec::new();
            buffer
                .extend(
                    <ProofWithPublicInputsTarget<
                        2,
                    > as circuit::SerdeCircuitTarget>::serialize(&self.proof1)?,
                );
            buffer
                .extend(
                    <ProofWithPublicInputsTarget<
                        2,
                    > as circuit::SerdeCircuitTarget>::serialize(&self.proof2)?,
                );
            buffer
                .extend(
                    <VerifierCircuitTarget as circuit::SerdeCircuitTarget>::serialize(
                        &self.verifier_circuit_target,
                    )?,
                );
            Ok(buffer)
        }
        fn deserialize(
            buffer: &mut plonky2::util::serialization::Buffer,
        ) -> plonky2::util::serialization::IoResult<Self>
        where
            Self: Sized,
        {
            Ok(Self {
                proof1: <ProofWithPublicInputsTarget<
                    2,
                > as circuit::SerdeCircuitTarget>::deserialize(buffer)?,
                proof2: <ProofWithPublicInputsTarget<
                    2,
                > as circuit::SerdeCircuitTarget>::deserialize(buffer)?,
                verifier_circuit_target: <VerifierCircuitTarget as circuit::SerdeCircuitTarget>::deserialize(
                    buffer,
                )?,
            })
        }
    }
}
pub mod deposits_accumulator_balance_aggregator {
    pub mod build_balance_accumulator_inner_level {
        use std::vec;
        use plonky2::{
            hash::poseidon::PoseidonHash,
            plonk::{
                circuit_builder::CircuitBuilder,
                circuit_data::{CircuitConfig, CircuitData, VerifierCircuitTarget},
                config::{GenericConfig, PoseidonGoldilocksConfig},
                proof::ProofWithPublicInputsTarget,
            },
            util::serialization::{Buffer, IoResult, Read, Write},
        };
        use plonky2_u32::gadgets::multiple_comparison::list_le_circuit;
        use crate::{
            deposits_accumulator_balance_aggregator::build_validator_balance_accumulator_circuit::{
                set_public_variables, ValidatorBalanceProofAccumulatorTargetsExt,
            },
            serialization::targets_serialization::{ReadTargets, WriteTargets},
            utils::{
                biguint::CircuitBuilderBiguint, hashing::sha256::make_circuits,
                utils::ETH_SHA256_BIT_SIZE,
            },
        };
        pub struct BalanceInnerCircuitTargets {
            pub proof1: ProofWithPublicInputsTarget<2>,
            pub proof2: ProofWithPublicInputsTarget<2>,
            pub verifier_circuit_target: VerifierCircuitTarget,
        }
        impl ReadTargets for BalanceInnerCircuitTargets {
            fn read_targets(data: &mut Buffer) -> IoResult<Self> {
                Ok(BalanceInnerCircuitTargets {
                    proof1: data.read_target_proof_with_public_inputs()?,
                    proof2: data.read_target_proof_with_public_inputs()?,
                    verifier_circuit_target: data.read_target_verifier_circuit()?,
                })
            }
        }
        impl WriteTargets for BalanceInnerCircuitTargets {
            fn write_targets(&self) -> IoResult<Vec<u8>> {
                let mut data = Vec::<u8>::new();
                data.write_target_proof_with_public_inputs(&self.proof1)?;
                data.write_target_proof_with_public_inputs(&self.proof2)?;
                data.write_target_verifier_circuit(&self.verifier_circuit_target)?;
                Ok(data)
            }
        }
        pub fn build_inner_level_circuit(
            inner_circuit_data: &CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
        ) -> (
            BalanceInnerCircuitTargets,
            plonky2::plonk::circuit_data::CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
        ) {
            const D: usize = 2;
            type C = PoseidonGoldilocksConfig;
            type F = <C as GenericConfig<D>>::F;
            let standard_recursion_config = CircuitConfig::standard_recursion_config();
            let mut builder = CircuitBuilder::<F, D>::new(standard_recursion_config);
            let verifier_circuit_target = VerifierCircuitTarget {
                constants_sigmas_cap: builder
                    .constant_merkle_cap(
                        &inner_circuit_data.verifier_only.constants_sigmas_cap,
                    ),
                circuit_digest: builder
                    .constant_hash(inner_circuit_data.verifier_only.circuit_digest),
            };
            let pt1 = builder.add_virtual_proof_with_pis(&inner_circuit_data.common);
            let pt2 = builder.add_virtual_proof_with_pis(&inner_circuit_data.common);
            builder
                .verify_proof::<
                    C,
                >(&pt1, &verifier_circuit_target, &inner_circuit_data.common);
            builder
                .verify_proof::<
                    C,
                >(&pt2, &verifier_circuit_target, &inner_circuit_data.common);
            let balances_root_hash1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_balances_root(&pt1);
            let balances_root_hash2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_balances_root(&pt2);
            for i in 0..ETH_SHA256_BIT_SIZE {
                builder
                    .connect(
                        balances_root_hash1[i].target,
                        balances_root_hash2[i].target,
                    );
            }
            let mut balances_root_hasher = make_circuits(
                &mut builder,
                (2 * ETH_SHA256_BIT_SIZE) as u64,
            );
            balances_root_hasher.message = [
                balances_root_hash1.as_slice(),
                balances_root_hash2.as_slice(),
            ]
                .concat()
                .try_into()
                .unwrap();
            let validator_commitment_root1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_validator_commitment(
                &pt1,
            );
            let validator_commitment_root2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_validator_commitment(
                &pt2,
            );
            builder
                .connect_hashes(validator_commitment_root1, validator_commitment_root2);
            let validator_commitment_root = builder
                .hash_n_to_hash_no_pad::<
                    PoseidonHash,
                >(
                    validator_commitment_root1
                        .elements
                        .iter()
                        .chain(validator_commitment_root2.elements.iter())
                        .cloned()
                        .collect(),
                );
            let accumulator_hash = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_validator_accumulator(
                &pt1,
            );
            let accumulator_hash2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_validator_accumulator(
                &pt2,
            );
            let accumulator_commitment_range_root = builder
                .hash_n_to_hash_no_pad::<
                    PoseidonHash,
                >(
                    accumulator_hash
                        .elements
                        .iter()
                        .chain(accumulator_hash2.elements.iter())
                        .cloned()
                        .collect(),
                );
            let deposit_count1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_deposit_count(
                &pt1,
            );
            let deposit_count2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_deposit_count(
                &pt2,
            );
            let deposit_count = builder.add(deposit_count1, deposit_count2);
            let current_eth1_deposit_index1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_current_eth1_deposit_index(
                &pt1,
            );
            let current_eth1_deposit_index2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_current_eth1_deposit_index(
                &pt2,
            );
            builder
                .connect_biguint(
                    &current_eth1_deposit_index1,
                    &current_eth1_deposit_index2,
                );
            let number_of_non_activated_validators1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_non_activated_validators(
                &pt1,
            );
            let number_of_non_activated_validators2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_non_activated_validators(
                &pt2,
            );
            let number_of_non_activated_validators = builder
                .add(
                    number_of_non_activated_validators1,
                    number_of_non_activated_validators2,
                );
            let number_of_active_validators1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_active_validators(
                &pt1,
            );
            let number_of_active_validators2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_active_validators(
                &pt2,
            );
            let number_of_active_validators = builder
                .add(number_of_active_validators1, number_of_active_validators2);
            let number_of_exitted_validators1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_exitted_validators(
                &pt1,
            );
            let number_of_exitted_validators2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_number_of_exitted_validators(
                &pt2,
            );
            let number_of_exitted_validators = builder
                .add(number_of_exitted_validators1, number_of_exitted_validators2);
            let sum1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_total_value(
                &pt1,
            );
            let sum2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_total_value(
                &pt2,
            );
            let mut sum = builder.add_biguint(&sum1, &sum2);
            sum.limbs.pop();
            let current_epoch1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_current_epoch(&pt1);
            let current_epoch2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_current_epoch(&pt2);
            builder.connect_biguint(&current_epoch1, &current_epoch2);
            let range_start1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_start(&pt1);
            let range_end1 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_end(&pt1);
            let range_start2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_start(&pt2);
            let range_end2 = <ProofWithPublicInputsTarget<
                2,
            > as ValidatorBalanceProofAccumulatorTargetsExt>::get_range_end(&pt2);
            let range_check1 = list_le_circuit(
                &mut builder,
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_start1])),
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_end1])),
                32,
            );
            let range_check2 = list_le_circuit(
                &mut builder,
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_end1])),
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_start2])),
                32,
            );
            let range_check3 = list_le_circuit(
                &mut builder,
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_start2])),
                <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([range_end2])),
                32,
            );
            let mut all = builder.and(range_check1, range_check2);
            all = builder.and(all, range_check3);
            let _true = builder._true();
            builder.connect(all.target, _true.target);
            set_public_variables(
                &mut builder,
                &sum,
                range_start1,
                range_end2,
                deposit_count,
                balances_root_hasher.digest.try_into().unwrap(),
                accumulator_commitment_range_root,
                validator_commitment_root,
                &current_eth1_deposit_index1,
                &current_epoch1,
                number_of_non_activated_validators,
                number_of_active_validators,
                number_of_exitted_validators,
            );
            let data = builder.build::<C>();
            (
                BalanceInnerCircuitTargets {
                    proof1: pt1,
                    proof2: pt2,
                    verifier_circuit_target,
                },
                data,
            )
        }
    }
    pub mod build_validator_balance_accumulator_circuit {
        use itertools::Itertools;
        use num::BigUint;
        use plonky2::{
            field::{goldilocks_field::GoldilocksField, types::Field64},
            hash::hash_types::HashOutTarget, iop::target::{BoolTarget, Target},
            plonk::{
                circuit_builder::CircuitBuilder, circuit_data::CircuitConfig,
                config::{GenericConfig, PoseidonGoldilocksConfig},
                proof::{ProofWithPublicInputs, ProofWithPublicInputsTarget},
            },
        };
        use plonky2_u32::gadgets::arithmetic_u32::U32Target;
        use crate::{
            deposits_accumulator_balance_aggregator::validator_balance_circuit_accumulator::validator_balance_verification_accumulator,
            utils::{
                biguint::BigUintTarget, utils::{ETH_SHA256_BIT_SIZE, POSEIDON_HASH_SIZE},
            },
        };
        use super::validator_balance_circuit_accumulator::ValidatorBalanceVerificationAccumulatorTargets;
        pub const RANGE_TOTAL_VALUE_PUB_INDEX: usize = 0;
        pub const RANGE_START_PUB_INDEX: usize = 2;
        pub const RANGE_END_PUB_INDEX: usize = 3;
        pub const RANGE_DEPOSIT_COUNT: usize = 4;
        pub const BALANCES_ROOT_PUB_INDEX: usize = 5;
        pub const RANGE_VALIDATOR_ACCUMULATOR_PUB_INDEX: usize = 261;
        pub const VALIDATORS_COMMITMENT_PUB_INDEX: usize = 265;
        pub const CURRENT_ETH1_DEPOSIT_PUB_INDEX: usize = 269;
        pub const CURRENT_EPOCH_PUB_INDEX: usize = 271;
        pub const NUMBER_OF_NON_ACTIVATED_VALIDATORS_INDEX: usize = 273;
        pub const NUMBER_OF_ACTIVE_VALIDATORS_INDEX: usize = 274;
        pub const NUMBER_OF_EXITTED_VALIDATORS_INDEX: usize = 275;
        pub type ValidatorBalanceAccumulatorProof = ProofWithPublicInputs<
            GoldilocksField,
            PoseidonGoldilocksConfig,
            2,
        >;
        pub trait ValidatorBalanceAccumulatorProofExt {
            fn get_range_total_value(&self) -> BigUint;
            fn get_start_pub_index(&self) -> u64;
            fn get_end_pub_index(&self) -> u64;
            fn range_deposit_count(&self) -> u64;
            fn get_range_balances_root(&self) -> [u64; ETH_SHA256_BIT_SIZE];
            fn get_range_validator_accumulator_index(
                &self,
            ) -> [String; POSEIDON_HASH_SIZE];
            fn get_validator_commitment(&self) -> [String; POSEIDON_HASH_SIZE];
            fn get_current_eth1_deposit_index(&self) -> BigUint;
            fn get_current_epoch(&self) -> BigUint;
            fn get_number_of_non_activated_validators(&self) -> u64;
            fn get_number_of_active_validators(&self) -> u64;
            fn get_number_of_exitted_validators(&self) -> u64;
        }
        impl ValidatorBalanceAccumulatorProofExt for ValidatorBalanceAccumulatorProof {
            fn get_range_total_value(&self) -> BigUint {
                BigUint::new(
                    self
                        .public_inputs[RANGE_TOTAL_VALUE_PUB_INDEX..RANGE_TOTAL_VALUE_PUB_INDEX
                            + 2]
                        .iter()
                        .map(|x| (x.0 % GoldilocksField::ORDER) as u32)
                        .collect(),
                )
            }
            fn get_current_epoch(&self) -> BigUint {
                BigUint::new(
                    self
                        .public_inputs[CURRENT_EPOCH_PUB_INDEX..CURRENT_EPOCH_PUB_INDEX
                            + 2]
                        .iter()
                        .map(|x| (x.0 % GoldilocksField::ORDER) as u32)
                        .collect(),
                )
            }
            fn get_start_pub_index(&self) -> u64 {
                self.public_inputs[RANGE_START_PUB_INDEX].0 % GoldilocksField::ORDER
            }
            fn get_end_pub_index(&self) -> u64 {
                self.public_inputs[RANGE_END_PUB_INDEX].0 % GoldilocksField::ORDER
            }
            fn range_deposit_count(&self) -> u64 {
                self.public_inputs[RANGE_DEPOSIT_COUNT].0 % GoldilocksField::ORDER
            }
            fn get_range_balances_root(&self) -> [u64; ETH_SHA256_BIT_SIZE] {
                self.public_inputs[BALANCES_ROOT_PUB_INDEX..BALANCES_ROOT_PUB_INDEX
                        + ETH_SHA256_BIT_SIZE]
                    .iter()
                    .map(|x| (x.0 % GoldilocksField::ORDER))
                    .collect_vec()
                    .try_into()
                    .unwrap()
            }
            fn get_range_validator_accumulator_index(
                &self,
            ) -> [String; POSEIDON_HASH_SIZE] {
                self.public_inputs[RANGE_VALIDATOR_ACCUMULATOR_PUB_INDEX..RANGE_VALIDATOR_ACCUMULATOR_PUB_INDEX
                        + POSEIDON_HASH_SIZE]
                    .iter()
                    .map(|x| (x.0 % GoldilocksField::ORDER).to_string())
                    .collect_vec()
                    .try_into()
                    .unwrap()
            }
            fn get_validator_commitment(&self) -> [String; POSEIDON_HASH_SIZE] {
                self.public_inputs[VALIDATORS_COMMITMENT_PUB_INDEX..VALIDATORS_COMMITMENT_PUB_INDEX
                        + POSEIDON_HASH_SIZE]
                    .iter()
                    .map(|x| (x.0 % GoldilocksField::ORDER).to_string())
                    .collect_vec()
                    .try_into()
                    .unwrap()
            }
            fn get_current_eth1_deposit_index(&self) -> BigUint {
                BigUint::new(
                    self
                        .public_inputs[CURRENT_ETH1_DEPOSIT_PUB_INDEX..CURRENT_ETH1_DEPOSIT_PUB_INDEX
                            + 2]
                        .iter()
                        .map(|x| (x.0 % GoldilocksField::ORDER) as u32)
                        .collect(),
                )
            }
            fn get_number_of_non_activated_validators(&self) -> u64 {
                self.public_inputs[NUMBER_OF_NON_ACTIVATED_VALIDATORS_INDEX].0
                    % GoldilocksField::ORDER
            }
            fn get_number_of_active_validators(&self) -> u64 {
                self.public_inputs[NUMBER_OF_ACTIVE_VALIDATORS_INDEX].0
                    % GoldilocksField::ORDER
            }
            fn get_number_of_exitted_validators(&self) -> u64 {
                self.public_inputs[NUMBER_OF_EXITTED_VALIDATORS_INDEX].0
                    % GoldilocksField::ORDER
            }
        }
        pub type ValidatorBalanceProofAccumulatorTargets = ProofWithPublicInputsTarget<
            2,
        >;
        pub trait ValidatorBalanceProofAccumulatorTargetsExt {
            fn get_range_total_value(&self) -> BigUintTarget;
            fn get_range_start(&self) -> Target;
            fn get_range_end(&self) -> Target;
            fn get_range_deposit_count(&self) -> Target;
            fn get_balances_root(&self) -> [BoolTarget; ETH_SHA256_BIT_SIZE];
            fn get_range_validator_accumulator(&self) -> HashOutTarget;
            fn get_validator_commitment(&self) -> HashOutTarget;
            fn get_current_eth1_deposit_index(&self) -> BigUintTarget;
            fn get_current_epoch(&self) -> BigUintTarget;
            fn get_number_of_non_activated_validators(&self) -> Target;
            fn get_number_of_active_validators(&self) -> Target;
            fn get_number_of_exitted_validators(&self) -> Target;
        }
        impl ValidatorBalanceProofAccumulatorTargetsExt
        for ValidatorBalanceProofAccumulatorTargets {
            fn get_range_total_value(&self) -> BigUintTarget {
                BigUintTarget {
                    limbs: self
                        .public_inputs[RANGE_TOTAL_VALUE_PUB_INDEX..RANGE_TOTAL_VALUE_PUB_INDEX
                            + 2]
                        .iter()
                        .cloned()
                        .map(|x| U32Target(x))
                        .collect_vec(),
                }
            }
            fn get_balances_root(&self) -> [BoolTarget; ETH_SHA256_BIT_SIZE] {
                self.public_inputs[BALANCES_ROOT_PUB_INDEX..BALANCES_ROOT_PUB_INDEX
                        + ETH_SHA256_BIT_SIZE]
                    .iter()
                    .cloned()
                    .map(|x| BoolTarget::new_unsafe(x))
                    .collect_vec()
                    .try_into()
                    .unwrap()
            }
            fn get_validator_commitment(&self) -> HashOutTarget {
                HashOutTarget {
                    elements: self
                        .public_inputs[VALIDATORS_COMMITMENT_PUB_INDEX..VALIDATORS_COMMITMENT_PUB_INDEX
                            + POSEIDON_HASH_SIZE]
                        .try_into()
                        .unwrap(),
                }
            }
            fn get_current_epoch(&self) -> BigUintTarget {
                BigUintTarget {
                    limbs: self
                        .public_inputs[CURRENT_EPOCH_PUB_INDEX..CURRENT_EPOCH_PUB_INDEX
                            + 2]
                        .iter()
                        .cloned()
                        .map(|x| U32Target(x))
                        .collect_vec(),
                }
            }
            fn get_number_of_non_activated_validators(&self) -> Target {
                self.public_inputs[NUMBER_OF_NON_ACTIVATED_VALIDATORS_INDEX]
            }
            fn get_number_of_active_validators(&self) -> Target {
                self.public_inputs[NUMBER_OF_ACTIVE_VALIDATORS_INDEX]
            }
            fn get_number_of_exitted_validators(&self) -> Target {
                self.public_inputs[NUMBER_OF_EXITTED_VALIDATORS_INDEX]
            }
            fn get_range_start(&self) -> Target {
                self.public_inputs[RANGE_START_PUB_INDEX]
            }
            fn get_range_end(&self) -> Target {
                self.public_inputs[RANGE_END_PUB_INDEX]
            }
            fn get_range_deposit_count(&self) -> Target {
                self.public_inputs[RANGE_DEPOSIT_COUNT]
            }
            fn get_range_validator_accumulator(&self) -> HashOutTarget {
                HashOutTarget {
                    elements: self
                        .public_inputs[RANGE_VALIDATOR_ACCUMULATOR_PUB_INDEX..RANGE_VALIDATOR_ACCUMULATOR_PUB_INDEX
                            + POSEIDON_HASH_SIZE]
                        .try_into()
                        .unwrap(),
                }
            }
            fn get_current_eth1_deposit_index(&self) -> BigUintTarget {
                BigUintTarget {
                    limbs: self
                        .public_inputs[CURRENT_ETH1_DEPOSIT_PUB_INDEX..CURRENT_ETH1_DEPOSIT_PUB_INDEX
                            + 2]
                        .iter()
                        .cloned()
                        .map(|x| U32Target(x))
                        .collect_vec(),
                }
            }
        }
        pub fn build_validator_balance_accumulator_circuit(
            validators_len: usize,
        ) -> (
            ValidatorBalanceVerificationAccumulatorTargets,
            plonky2::plonk::circuit_data::CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
        ) {
            const D: usize = 2;
            type C = PoseidonGoldilocksConfig;
            type F = <C as GenericConfig<D>>::F;
            let mut builder = CircuitBuilder::<
                F,
                D,
            >::new(CircuitConfig::standard_recursion_config());
            let targets = validator_balance_verification_accumulator(
                &mut builder,
                validators_len,
            );
            let circuit_data = builder.build::<C>();
            (targets, circuit_data)
        }
        pub fn set_public_variables(
            builder: &mut CircuitBuilder<
                plonky2::field::goldilocks_field::GoldilocksField,
                2,
            >,
            range_total_value: &BigUintTarget,
            range_start: Target,
            range_end: Target,
            range_deposit_count: Target,
            balances_root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            range_validator_accumulator: HashOutTarget,
            validator_commitment: HashOutTarget,
            current_eth1_deposit_index: &BigUintTarget,
            current_epoch: &BigUintTarget,
            number_of_non_activated_validators: Target,
            number_of_active_validators: Target,
            number_of_exitted_validators: Target,
        ) {
            builder
                .register_public_inputs(
                    &range_total_value.limbs.iter().map(|x| x.0).collect_vec(),
                );
            builder.register_public_input(range_start);
            builder.register_public_input(range_end);
            builder.register_public_input(range_deposit_count);
            builder.register_public_inputs(&balances_root.map(|x| x.target));
            builder.register_public_inputs(&range_validator_accumulator.elements);
            builder.register_public_inputs(&validator_commitment.elements);
            builder
                .register_public_inputs(
                    &current_eth1_deposit_index.limbs.iter().map(|x| x.0).collect_vec(),
                );
            builder
                .register_public_inputs(
                    &current_epoch.limbs.iter().map(|x| x.0).collect_vec(),
                );
            builder.register_public_input(number_of_non_activated_validators);
            builder.register_public_input(number_of_active_validators);
            builder.register_public_input(number_of_exitted_validators);
        }
    }
    pub mod validator_balance_circuit_accumulator {
        use itertools::{izip, Itertools};
        use num::BigUint;
        use plonky2::{
            field::extension::Extendable,
            hash::{
                hash_types::{HashOutTarget, RichField},
                poseidon::PoseidonHash,
            },
            iop::target::{BoolTarget, Target},
            plonk::circuit_builder::CircuitBuilder,
            util::serialization::{Buffer, IoResult, Read, Write},
        };
        use plonky2_u32::gadgets::arithmetic_u32::U32Target;
        use crate::{
            serialization::targets_serialization::{ReadTargets, WriteTargets},
            utils::{
                biguint::{BigUintTarget, CircuitBuilderBiguint},
                hashing::{
                    hash_tree_root_poseidon::hash_tree_root_poseidon,
                    is_valid_merkle_branch::{
                        assert_merkle_proof_is_valid, restore_merkle_root, MerkleBranch,
                        Sha256,
                    },
                    poseidon::hash_poseidon,
                    validator_hash_tree_root_poseidon::{
                        hash_validator_poseidon, ValidatorTarget,
                    },
                },
                utils::{
                    biguint_to_le_bits_target, create_bool_target_array,
                    create_sha256_merkle_proof,
                },
            },
        };
        pub struct ValidatorStatusCountsTarget {
            pub active_validators_count: Target,
            pub exitted_validators_count: Target,
            pub not_activated_validators_count: Target,
        }
        impl ValidatorStatusCountsTarget {
            pub fn new<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
            ) -> Self {
                Self {
                    active_validators_count: builder.zero(),
                    exitted_validators_count: builder.zero(),
                    not_activated_validators_count: builder.zero(),
                }
            }
        }
        impl ReadTargets for ValidatorStatusCountsTarget {
            fn read_targets(data: &mut Buffer) -> IoResult<Self> {
                Ok(Self {
                    active_validators_count: data.read_target().unwrap(),
                    exitted_validators_count: data.read_target().unwrap(),
                    not_activated_validators_count: data.read_target().unwrap(),
                })
            }
        }
        impl WriteTargets for ValidatorStatusCountsTarget {
            fn write_targets(&self) -> IoResult<Vec<u8>> {
                let mut data = Vec::<u8>::new();
                data.write_target(self.active_validators_count)?;
                data.write_target(self.exitted_validators_count)?;
                data.write_target(self.not_activated_validators_count)?;
                Ok(data)
            }
        }
        pub type BLSPubkey = [BoolTarget; 384];
        pub type BLSSignature = [BoolTarget; 768];
        pub type Bytes32 = [BoolTarget; 256];
        pub type Gwei = BigUintTarget;
        pub struct DepositDataTarget {
            pub pubkey: BLSPubkey,
            pub withdrawal_credentials: Bytes32,
            pub amount: Gwei,
            pub signature: BLSSignature,
        }
        impl DepositDataTarget {
            pub fn new<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
            ) -> Self {
                Self {
                    pubkey: create_bool_target_array::<F, D, 384>(builder),
                    withdrawal_credentials: create_bool_target_array::<
                        F,
                        D,
                        256,
                    >(builder),
                    amount: builder.add_virtual_biguint_target(2),
                    signature: create_bool_target_array::<F, D, 768>(builder),
                }
            }
        }
        impl ReadTargets for DepositDataTarget {
            fn read_targets(data: &mut Buffer) -> IoResult<Self> {
                let pubkey: BLSPubkey = data.read_target_bool_vec()?.try_into().unwrap();
                let withdrawal_credentials: Bytes32 = data
                    .read_target_bool_vec()?
                    .try_into()
                    .unwrap();
                let amount: Gwei = Gwei::read_targets(data)?;
                let signature: BLSSignature = data
                    .read_target_bool_vec()?
                    .try_into()
                    .unwrap();
                Ok(Self {
                    pubkey,
                    withdrawal_credentials,
                    amount,
                    signature,
                })
            }
        }
        impl WriteTargets for DepositDataTarget {
            fn write_targets(&self) -> IoResult<Vec<u8>> {
                let mut data = Vec::<u8>::new();
                data.write_target_bool_vec(&self.pubkey)?;
                data.write_target_bool_vec(&self.withdrawal_credentials)?;
                data.extend(Gwei::write_targets(&self.amount)?);
                data.write_target_bool_vec(&self.signature)?;
                Ok(data)
            }
        }
        pub struct ValidatorBalanceVerificationAccumulatorTargets {
            pub balances_leaves: Vec<Sha256>,
            pub balances_root: Sha256,
            pub non_zero_validator_leaves_mask: Vec<BoolTarget>,
            pub balances_proofs: Vec<MerkleBranch<22>>,
            pub validators: Vec<ValidatorTarget>,
            pub validator_indices: Vec<BigUintTarget>,
            pub current_epoch: BigUintTarget,
            pub deposits_data: Vec<DepositDataTarget>,
            pub validators_poseidon_root: HashOutTarget,
            pub validators_commitment_in_range: HashOutTarget,
            pub validator_status_counts: ValidatorStatusCountsTarget,
            pub range_total_balance: BigUintTarget,
        }
        impl ReadTargets for ValidatorBalanceVerificationAccumulatorTargets {
            fn read_targets(data: &mut Buffer) -> IoResult<Self> {
                let validators_len = data.read_usize()?;
                Ok(Self {
                    balances_leaves: (0..validators_len)
                        .map(|_| {
                            data.read_target_bool_vec()
                                .expect("read target bool vec fails")
                                .try_into()
                                .expect("this fails")
                        })
                        .collect(),
                    balances_root: data
                        .read_target_bool_vec()
                        .unwrap()
                        .try_into()
                        .unwrap(),
                    non_zero_validator_leaves_mask: data.read_target_bool_vec().unwrap(),
                    balances_proofs: (0..validators_len)
                        .map(|_| MerkleBranch::<DEPTH>::read_targets(data).unwrap())
                        .collect_vec(),
                    validators: (0..validators_len)
                        .map(|_| {
                            ValidatorTarget::read_targets(data)
                                .expect("ValidatorTarget::read_targets fails")
                        })
                        .collect(),
                    validator_indices: (0..validators_len)
                        .map(|_| BigUintTarget::read_targets(data).unwrap())
                        .collect_vec(),
                    current_epoch: BigUintTarget::read_targets(data).unwrap(),
                    deposits_data: (0..validators_len)
                        .map(|_| DepositDataTarget::read_targets(data).unwrap())
                        .collect_vec(),
                    validators_poseidon_root: data.read_target_hash().unwrap(),
                    validators_commitment_in_range: data.read_target_hash().unwrap(),
                    validator_status_counts: ValidatorStatusCountsTarget::read_targets(
                            data,
                        )
                        .unwrap(),
                    range_total_balance: BigUintTarget::read_targets(data).unwrap(),
                })
            }
        }
        impl WriteTargets for ValidatorBalanceVerificationAccumulatorTargets {
            fn write_targets(&self) -> IoResult<Vec<u8>> {
                let mut data = Vec::<u8>::new();
                data.write_usize(self.validators.len())?;
                for balance in &self.balances_leaves {
                    data.write_target_bool_vec(balance)?;
                }
                data.write_target_bool_vec(&self.balances_root)?;
                data.write_target_bool_vec(&self.non_zero_validator_leaves_mask)?;
                for balances_proof in &self.balances_proofs {
                    data.extend(&balances_proof.write_targets()?);
                }
                for validator in &self.validators {
                    data.extend(ValidatorTarget::write_targets(validator)?);
                }
                for gindex in &self.validator_indices {
                    data.extend(gindex.write_targets()?);
                }
                data.extend(self.current_epoch.write_targets().unwrap());
                for deposit in &self.deposits_data {
                    data.extend(deposit.write_targets()?);
                }
                data.write_target_hash(&self.validators_poseidon_root)?;
                data.write_target_hash(&self.validators_commitment_in_range)?;
                data.extend(self.validator_status_counts.write_targets().unwrap());
                data.extend(self.range_total_balance.write_targets().unwrap());
                Ok(data)
            }
        }
        const DEPTH: usize = 22;
        struct CircuitInputTargets {
            pub balances_leaves: Vec<Sha256>,
            pub balances_root: Sha256,
            pub non_zero_validator_leaves_mask: Vec<BoolTarget>,
            pub balances_proofs: Vec<MerkleBranch<DEPTH>>,
            pub validators: Vec<ValidatorTarget>,
            pub validator_indices: Vec<BigUintTarget>,
            pub current_epoch: BigUintTarget,
            pub deposits_data: Vec<DepositDataTarget>,
            pub validators_poseidon_root: HashOutTarget,
        }
        fn read_input<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            validators_count: usize,
        ) -> CircuitInputTargets {
            let balances_leaves: Vec<Sha256> = (0..validators_count)
                .map(|_| create_bool_target_array(builder))
                .collect_vec();
            let balances_root: Sha256 = create_bool_target_array(builder);
            let non_zero_validator_leaves_mask = (0..validators_count)
                .map(|_| builder.add_virtual_bool_target_safe())
                .collect_vec();
            let balances_proofs: Vec<MerkleBranch<DEPTH>> = (0..validators_count)
                .map(|_| create_sha256_merkle_proof(builder))
                .collect_vec();
            let validators: Vec<ValidatorTarget> = (0..validators_count)
                .map(|_| ValidatorTarget::new(builder))
                .collect_vec();
            let validator_indices: Vec<BigUintTarget> = (0..validators_count)
                .map(|_| builder.add_virtual_biguint_target(2))
                .collect_vec();
            let current_epoch = builder.add_virtual_biguint_target(2);
            let deposits_data = (0..validators_count)
                .map(|_| DepositDataTarget::new(builder))
                .collect_vec();
            let validators_poseidon_root = builder.add_virtual_hash();
            CircuitInputTargets {
                balances_leaves,
                balances_root,
                non_zero_validator_leaves_mask,
                balances_proofs,
                validators,
                validator_indices,
                current_epoch,
                deposits_data,
                validators_poseidon_root,
            }
        }
        fn calc_validators_commitment<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            validators: &[ValidatorTarget],
            non_zero_validator_leaves_mask: &[BoolTarget],
        ) -> HashOutTarget {
            let validator_hashes_targets = validators
                .iter()
                .zip(non_zero_validator_leaves_mask)
                .map(|(validator, is_non_zero_leaf)| {
                    HashOutTarget::from_vec(
                        hash_validator_poseidon(builder, validator)
                            .elements
                            .iter()
                            .map(|&element| {
                                builder.mul(element, is_non_zero_leaf.target)
                            })
                            .collect_vec(),
                    )
                })
                .flat_map(|hash| hash.elements)
                .collect_vec();
            hash_poseidon(builder, validator_hashes_targets)
        }
        struct ValidatorStatusTarget {
            is_active: BoolTarget,
            is_exitted: BoolTarget,
        }
        fn get_validator_status<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            current_epoch: &BigUintTarget,
            activation_epoch: &BigUintTarget,
            exit_epoch: &BigUintTarget,
        ) -> ValidatorStatusTarget {
            let current_gte_activation_epoch_pred = builder
                .gte_biguint(current_epoch, activation_epoch);
            let current_lt_exit_epoch_pred = builder
                .lt_biguint(current_epoch, exit_epoch);
            let is_active = builder
                .and(current_gte_activation_epoch_pred, current_lt_exit_epoch_pred);
            let is_exitted = builder.gte_biguint(current_epoch, activation_epoch);
            ValidatorStatusTarget {
                is_active,
                is_exitted,
            }
        }
        fn increment_if_true<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            target: &mut Target,
            by: Target,
            predicate: BoolTarget,
        ) {
            let incr = builder.mul(by, predicate.target);
            *target = builder.add(*target, incr);
        }
        fn accumulate_validator_statuses<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            current_epoch: &BigUintTarget,
            validators: &[ValidatorTarget],
            non_zero_validator_leaves_mask: &[BoolTarget],
        ) -> ValidatorStatusCountsTarget {
            let mut counts = ValidatorStatusCountsTarget::new(builder);
            for (validator, &is_non_zero_leaf) in validators
                .iter()
                .zip(non_zero_validator_leaves_mask)
            {
                let validator_status = get_validator_status(
                    builder,
                    current_epoch,
                    &validator.activation_epoch,
                    &validator.exit_epoch,
                );
                let validator_is_active_or_exitted_pred = builder
                    .or(validator_status.is_active, validator_status.is_exitted);
                let validator_is_not_active_or_exitted_pred = builder
                    .not(validator_is_active_or_exitted_pred);
                counts.active_validators_count = builder
                    .add(
                        counts.active_validators_count,
                        validator_status.is_active.target,
                    );
                increment_if_true(
                    builder,
                    &mut counts.active_validators_count,
                    validator_status.is_active.target,
                    is_non_zero_leaf,
                );
                increment_if_true(
                    builder,
                    &mut counts.exitted_validators_count,
                    validator_status.is_exitted.target,
                    is_non_zero_leaf,
                );
                increment_if_true(
                    builder,
                    &mut counts.not_activated_validators_count,
                    validator_is_not_active_or_exitted_pred.target,
                    is_non_zero_leaf,
                );
            }
            counts
        }
        fn extract_balance_from_leaf<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            leaf: &Sha256,
            offset: &BigUintTarget,
        ) -> BigUintTarget {
            let zero = builder.constant(F::from_canonical_u32(0));
            let one = builder.constant(F::from_canonical_u32(1));
            let two = builder.constant(F::from_canonical_u32(2));
            let const_64 = builder.constant_biguint(&BigUint::from(64u64));
            let range_begin = builder.mul_biguint(&const_64, offset);
            let range_end = builder.add_biguint(&range_begin, &const_64);
            let mut balance = builder.constant_biguint(&BigUint::from(0u64));
            let mut is_inside_range_pred = builder.zero();
            for i in 0..leaf.len() {
                let idx = builder.constant_biguint(&BigUint::from(i));
                let is_range_begin_pred = builder.eq_biguint(&idx, &range_begin);
                let is_range_end_pred = builder.eq_biguint(&idx, &range_end);
                is_inside_range_pred = builder
                    .add(is_inside_range_pred, is_range_begin_pred.target);
                is_inside_range_pred = builder
                    .sub(is_inside_range_pred, is_range_end_pred.target);
                let multiplier_target = builder
                    .select(BoolTarget::new_unsafe(is_inside_range_pred), two, one);
                let multiplier = biguint_from_target(builder, multiplier_target);
                let addend_target = builder
                    .select(BoolTarget::new_unsafe(is_inside_range_pred), one, zero);
                let addend = biguint_from_target(builder, addend_target);
                balance = builder.mul_add_biguint(&balance, &multiplier, &addend);
            }
            balance
        }
        fn biguint_from_target<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            target: Target,
        ) -> BigUintTarget {
            BigUintTarget {
                limbs: <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        U32Target(target),
                        U32Target(builder.zero()),
                    ]),
                ),
            }
        }
        fn gindex_from_index_at_depth<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            index: &BigUintTarget,
            depth: u32,
        ) -> BigUintTarget {
            let first_leaf_gindex = builder
                .constant_biguint(&BigUint::from(2u64.pow(depth)));
            builder.add_biguint(&first_leaf_gindex, index)
        }
        fn prove_and_accumulate_balances<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            leaves: &[Sha256],
            branches: &[MerkleBranch<22>],
            root: &Sha256,
            validator_indices: &[BigUintTarget],
        ) -> BigUintTarget {
            let mut total_balance = builder.constant_biguint(&BigUint::from(0u64));
            for (leaf, branch, validator_index) in ::itertools::__std_iter::IntoIterator::into_iter(
                    leaves,
                )
                .zip(branches)
                .zip(validator_indices)
                .map(|((a, b), b)| (a, b, b))
            {
                let four = builder.constant_biguint(&BigUint::from(4u64));
                let validator_gindex = gindex_from_index_at_depth(
                    builder,
                    validator_index,
                    24,
                );
                let balance_gindex = builder.div_biguint(&validator_gindex, &four);
                assert_merkle_proof_is_valid(
                    builder,
                    leaf,
                    root,
                    branch,
                    &balance_gindex,
                );
                let validator_balance_offset = builder
                    .rem_biguint(&validator_index, &four);
                let balance = extract_balance_from_leaf(
                    builder,
                    leaf,
                    &validator_balance_offset,
                );
                total_balance = builder.add_biguint(&total_balance, &balance);
            }
            total_balance
        }
        pub fn validator_balance_verification_accumulator<
            F: RichField + Extendable<D>,
            const D: usize,
        >(
            builder: &mut CircuitBuilder<F, D>,
            validators_count: usize,
        ) -> ValidatorBalanceVerificationAccumulatorTargets {
            if !validators_count.is_power_of_two() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("validators_count must be a power of two"),
                    );
                };
            }
            let input = read_input(builder, validators_count);
            let validators_commitment_in_range = calc_validators_commitment(
                builder,
                &input.validators,
                &input.non_zero_validator_leaves_mask,
            );
            let validator_status_counts = accumulate_validator_statuses(
                builder,
                &input.current_epoch,
                &input.validators,
                &input.non_zero_validator_leaves_mask,
            );
            let range_total_balance = prove_and_accumulate_balances(
                builder,
                &input.balances_leaves,
                &input.balances_proofs,
                &input.balances_root,
                &input.validator_indices,
            );
            ValidatorBalanceVerificationAccumulatorTargets {
                balances_leaves: input.balances_leaves,
                balances_root: input.balances_root,
                non_zero_validator_leaves_mask: input.non_zero_validator_leaves_mask,
                balances_proofs: input.balances_proofs,
                validators: input.validators,
                validator_indices: input.validator_indices,
                current_epoch: input.current_epoch,
                deposits_data: input.deposits_data,
                validators_poseidon_root: input.validators_poseidon_root,
                validators_commitment_in_range,
                validator_status_counts,
                range_total_balance,
            }
        }
        pub struct Targets {
            pub leaf: Sha256,
            pub proof: MerkleBranch<1>,
            pub gindex: BigUintTarget,
        }
        pub fn test_circuit<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
        ) -> Targets {
            let leaf = create_bool_target_array(builder);
            let proof: MerkleBranch<1> = create_sha256_merkle_proof(builder);
            let gindex = builder.add_virtual_biguint_target(2);
            let root = restore_merkle_root(builder, &leaf, &proof, &gindex);
            let bits = biguint_to_le_bits_target::<F, D, 2>(builder, &gindex);
            builder
                .register_public_inputs(
                    root.map(|bool_target| bool_target.target).as_slice(),
                );
            builder
                .register_public_inputs(
                    bits
                        .iter()
                        .map(|bool_target| bool_target.target)
                        .collect_vec()
                        .as_slice(),
                );
            Targets { leaf, proof, gindex }
        }
    }
}
pub mod deposits_accumulator_commitment_mapper_and_bls_verification {}
pub mod final_layer {
    pub mod build_final_circuit {
        use crate::{
            common_targets::Sha256Target,
            utils::{
                biguint::{BigUintTarget, CircuitBuilderBiguint},
                hashing::{
                    is_valid_merkle_branch::{
                        is_valid_merkle_branch_sha256, IsValidMerkleBranchTargets,
                    },
                    sha256::{sha256, sha256_pair},
                },
                utils::{
                    biguint_to_bits_target, create_bool_target_array, ssz_num_to_bits,
                    target_to_le_bits, ETH_SHA256_BIT_SIZE,
                },
            },
            validators_commitment_mapper::first_level::ValidatorsCommitmentMapperFirstLevel,
            withdrawal_credentials_balance_aggregator::first_level::WithdrawalCredentialsBalanceAggregatorFirstLevel,
        };
        use circuit::{Circuit, CircuitOutputTarget, TargetsWithPublicInputs};
        use itertools::Itertools;
        use num::{BigUint, FromPrimitive};
        use plonky2::{
            field::{goldilocks_field::GoldilocksField, types::Field},
            fri::{reduction_strategies::FriReductionStrategy, FriConfig},
            hash::hash_types::HashOutTarget, iop::target::BoolTarget,
            plonk::{
                circuit_builder::CircuitBuilder,
                circuit_data::{CircuitConfig, CircuitData, VerifierCircuitTarget},
                config::{GenericConfig, PoseidonGoldilocksConfig},
                proof::ProofWithPublicInputsTarget,
            },
        };
        pub struct BalanceFinalLayerTargets {
            pub proof: ProofWithPublicInputsTarget<2>,
            pub verifier_circuit_target: VerifierCircuitTarget,
        }
        pub struct CommitmentMapperFinalLayerTargets {
            pub proof: ProofWithPublicInputsTarget<2>,
            pub verifier_circuit_target: VerifierCircuitTarget,
        }
        pub struct FinalCircuitTargets<const N: usize> {
            pub balance_circuit_targets: BalanceFinalLayerTargets,
            pub commitment_mapper_circuit_targets: CommitmentMapperFinalLayerTargets,
            pub slot: BigUintTarget,
            pub slot_branch: [[BoolTarget; ETH_SHA256_BIT_SIZE]; 5],
            pub state_root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            pub block_root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            pub state_root_branch: [[BoolTarget; ETH_SHA256_BIT_SIZE]; 3],
            pub validators_branch: [[BoolTarget; ETH_SHA256_BIT_SIZE]; 5],
            pub balance_branch: [[BoolTarget; ETH_SHA256_BIT_SIZE]; 5],
            pub balance_sum: BigUintTarget,
            pub withdrawal_credentials: [[BoolTarget; ETH_SHA256_BIT_SIZE]; N],
            pub validator_size_bits: [BoolTarget; ETH_SHA256_BIT_SIZE],
        }
        const D: usize = 2;
        type C = PoseidonGoldilocksConfig;
        type F = <C as GenericConfig<D>>::F;
        pub fn build_final_circuit<const N: usize>(
            balance_data: &CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
            commitment_data: &CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
        ) -> (
            FinalCircuitTargets<N>,
            plonky2::plonk::circuit_data::CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
        ) {
            let final_config = CircuitConfig::standard_recursion_config();
            let mut builder = CircuitBuilder::<F, D>::new(final_config);
            let (
                balance_proof_targets,
                balance_verifier_circuit_target,
                balances_pi_target,
            ) = setup_balance_targets::<8, N>(&mut builder, balance_data);
            let (
                commitment_mapper_proof_targets,
                commitment_mapper_verifier_circuit_target,
                commitment_mapper_poseidon_root,
                commitment_mapper_sha256_root,
            ) = setup_commitment_mapper_targets(&mut builder, commitment_data);
            builder
                .connect_hashes(
                    commitment_mapper_poseidon_root,
                    balances_pi_target.range_validator_commitment,
                );
            let state_root = create_bool_target_array(&mut builder);
            let block_root = create_bool_target_array(&mut builder);
            let state_root_branch = create_and_connect_merkle_branch(
                &mut builder,
                11,
                &state_root,
                &block_root,
                3,
            );
            let validator_size_bits = create_bool_target_array(&mut builder);
            let validators_root = sha256_pair(
                &mut builder,
                &commitment_mapper_sha256_root,
                &validator_size_bits,
            );
            let validators_merkle_branch = create_and_connect_merkle_branch(
                &mut builder,
                43,
                &validators_root,
                &state_root,
                5,
            );
            let balances_root = sha256_pair(
                &mut builder,
                &balances_pi_target.range_balances_root,
                &validator_size_bits,
            );
            let balance_merkle_branch = create_and_connect_merkle_branch(
                &mut builder,
                44,
                &balances_root,
                &state_root,
                5,
            );
            let slot = builder.add_virtual_biguint_target(2);
            verify_slot_is_in_range(
                &mut builder,
                &slot,
                &balances_pi_target.current_epoch,
            );
            let slot_bits = ssz_num_to_bits(&mut builder, &slot, 64);
            let slot_merkle_branch = create_and_connect_merkle_branch(
                &mut builder,
                34,
                &slot_bits,
                &state_root,
                5,
            );
            let final_sum_bits = biguint_to_bits_target::<
                F,
                D,
                2,
            >(&mut builder, &balances_pi_target.range_total_value);
            let flattened_withdrawal_credentials = balances_pi_target
                .withdrawal_credentials
                .iter()
                .flat_map(|array| array.iter())
                .cloned()
                .collect_vec();
            let number_of_non_activated_validators_bits = target_to_le_bits(
                &mut builder,
                balances_pi_target.number_of_non_activated_validators,
            );
            let number_of_active_validators_bits = target_to_le_bits(
                &mut builder,
                balances_pi_target.number_of_active_validators,
            );
            let number_of_exitted_validators_bits = target_to_le_bits(
                &mut builder,
                balances_pi_target.number_of_exitted_validators,
            );
            let mut public_inputs_hash = sha256(
                &mut builder,
                &[
                    block_root.as_slice(),
                    flattened_withdrawal_credentials.as_slice(),
                    final_sum_bits.as_slice(),
                    number_of_non_activated_validators_bits.as_slice(),
                    number_of_active_validators_bits.as_slice(),
                    number_of_exitted_validators_bits.as_slice(),
                ]
                    .concat(),
            );
            public_inputs_hash[0] = builder._false();
            public_inputs_hash[1] = builder._false();
            public_inputs_hash[2] = builder._false();
            let public_inputs_hash_bytes = public_inputs_hash
                .chunks(8)
                .map(|x| builder.le_sum(x.iter().rev()))
                .collect_vec();
            builder.register_public_inputs(&public_inputs_hash_bytes);
            let data = builder.build::<C>();
            (
                FinalCircuitTargets {
                    balance_circuit_targets: BalanceFinalLayerTargets {
                        proof: balance_proof_targets.clone(),
                        verifier_circuit_target: balance_verifier_circuit_target,
                    },
                    commitment_mapper_circuit_targets: CommitmentMapperFinalLayerTargets {
                        proof: commitment_mapper_proof_targets,
                        verifier_circuit_target: commitment_mapper_verifier_circuit_target,
                    },
                    validators_branch: validators_merkle_branch
                        .branch
                        .try_into()
                        .unwrap(),
                    block_root,
                    state_root,
                    state_root_branch: state_root_branch.branch.try_into().unwrap(),
                    balance_branch: balance_merkle_branch.branch.try_into().unwrap(),
                    balance_sum: balances_pi_target.range_total_value,
                    slot,
                    slot_branch: slot_merkle_branch.branch.try_into().unwrap(),
                    withdrawal_credentials: balances_pi_target.withdrawal_credentials,
                    validator_size_bits,
                },
                data,
            )
        }
        fn setup_balance_targets<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >(
            builder: &mut CircuitBuilder<F, D>,
            data: &CircuitData<F, C, D>,
        ) -> (
            ProofWithPublicInputsTarget<D>,
            VerifierCircuitTarget,
            CircuitOutputTarget<
                WithdrawalCredentialsBalanceAggregatorFirstLevel<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                >,
            >,
        )
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            let (proof_targets, verifier_circuit_target) = setup_proof_targets(
                data,
                builder,
            );
            let public_inputs_target = WithdrawalCredentialsBalanceAggregatorFirstLevel::<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >::read_public_inputs_target(&proof_targets.public_inputs);
            (proof_targets, verifier_circuit_target, public_inputs_target)
        }
        fn setup_commitment_mapper_targets(
            builder: &mut CircuitBuilder<F, D>,
            data: &CircuitData<F, C, D>,
        ) -> (
            ProofWithPublicInputsTarget<D>,
            VerifierCircuitTarget,
            HashOutTarget,
            Sha256Target,
        ) {
            let (proof_targets, verifier_circuit_target) = setup_proof_targets(
                data,
                builder,
            );
            let output = ValidatorsCommitmentMapperFirstLevel::read_public_inputs_target(
                &proof_targets.public_inputs,
            );
            (
                proof_targets,
                verifier_circuit_target,
                output.poseidon_hash_tree_root,
                output.sha256_hash_tree_root,
            )
        }
        fn verify_slot_is_in_range(
            builder: &mut CircuitBuilder<GoldilocksField, 2>,
            slot: &BigUintTarget,
            current_epoch: &BigUintTarget,
        ) -> () {
            let slots_per_epoch = builder
                .constant_biguint(&BigUint::from_u32(32).unwrap());
            let slot_epoch = builder.div_biguint(slot, &slots_per_epoch);
            builder.connect_biguint(&slot_epoch, current_epoch);
        }
        fn setup_proof_targets(
            circuit_data: &CircuitData<
                plonky2::field::goldilocks_field::GoldilocksField,
                PoseidonGoldilocksConfig,
                2,
            >,
            builder: &mut CircuitBuilder<GoldilocksField, 2>,
        ) -> (ProofWithPublicInputsTarget<2>, VerifierCircuitTarget) {
            let verifier_circuit_target = VerifierCircuitTarget {
                constants_sigmas_cap: builder
                    .add_virtual_cap(circuit_data.common.config.fri_config.cap_height),
                circuit_digest: builder.add_virtual_hash(),
            };
            let proof_targets: ProofWithPublicInputsTarget<2> = builder
                .add_virtual_proof_with_pis(&circuit_data.common);
            builder
                .verify_proof::<
                    PoseidonGoldilocksConfig,
                >(&proof_targets, &verifier_circuit_target, &circuit_data.common);
            (proof_targets, verifier_circuit_target)
        }
        fn create_and_connect_merkle_branch(
            builder: &mut CircuitBuilder<GoldilocksField, 2>,
            index: u32,
            leaf_targets: &[BoolTarget],
            root_targets: &[BoolTarget; ETH_SHA256_BIT_SIZE],
            depth: usize,
        ) -> IsValidMerkleBranchTargets {
            let merkle_branch = is_valid_merkle_branch_sha256(builder, depth);
            let index = builder.constant(GoldilocksField::from_canonical_u32(index));
            builder.connect(merkle_branch.index, index);
            for i in 0..ETH_SHA256_BIT_SIZE {
                builder.connect(merkle_branch.leaf[i].target, leaf_targets[i].target);
            }
            for i in 0..ETH_SHA256_BIT_SIZE {
                builder.connect(merkle_branch.root[i].target, root_targets[i].target);
            }
            merkle_branch
        }
        #[allow(dead_code)]
        fn create_final_config() -> CircuitConfig {
            let standard_recursion_config = CircuitConfig::standard_recursion_config();
            CircuitConfig {
                num_routed_wires: 37,
                fri_config: FriConfig {
                    rate_bits: 8,
                    cap_height: 0,
                    proof_of_work_bits: 20,
                    reduction_strategy: FriReductionStrategy::MinSize(None),
                    num_query_rounds: 10,
                },
                ..standard_recursion_config
            }
        }
    }
}
pub mod serialization {
    pub mod generator_serializer {
        use plonky2::{
            field::extension::Extendable,
            gadgets::{
                arithmetic::EqualityGenerator,
                arithmetic_extension::QuotientGeneratorExtension,
                range_check::LowHighGenerator, split_base::BaseSumGenerator,
                split_join::{SplitGenerator, WireSplitGenerator},
            },
            gates::reducing::ReducingGenerator,
            gates::reducing_extension::ReducingGenerator as ReducingExtensionGenerator,
            gates::{
                arithmetic_base::{ArithmeticBaseGenerator, ArithmeticGate},
                arithmetic_extension::{
                    ArithmeticExtensionGate, ArithmeticExtensionGenerator,
                },
                base_sum::{BaseSplitGenerator, BaseSumGate},
                constant::ConstantGate,
                coset_interpolation::{CosetInterpolationGate, InterpolationGenerator},
                exponentiation::{ExponentiationGate, ExponentiationGenerator},
                lookup::{LookupGate, LookupGenerator},
                lookup_table::{LookupTableGate, LookupTableGenerator},
                multiplication_extension::{MulExtensionGate, MulExtensionGenerator},
                noop::NoopGate, poseidon::{PoseidonGate, PoseidonGenerator},
                poseidon_mds::{PoseidonMdsGate, PoseidonMdsGenerator},
                public_input::PublicInputGate,
                random_access::{RandomAccessGate, RandomAccessGenerator},
                reducing::ReducingGate, reducing_extension::ReducingExtensionGate,
            },
            get_gate_tag_impl, get_generator_tag_impl, hash::hash_types::RichField,
            impl_gate_serializer, impl_generator_serializer,
            iop::generator::{
                ConstantGenerator, CopyGenerator, NonzeroTestGenerator,
                RandomValueGenerator,
            },
            plonk::config::{AlgebraicHasher, GenericConfig},
            read_gate_impl, read_generator_impl,
            recursion::dummy_circuit::DummyProofGenerator,
            util::serialization::{GateSerializer, WitnessGeneratorSerializer},
        };
        use plonky2_u32::gates::{
            add_many_u32::U32AddManyGate, add_many_u32::U32AddManyGenerator,
            arithmetic_u32::{U32ArithmeticGate, U32ArithmeticGenerator},
            comparison::{ComparisonGate, ComparisonGenerator},
            range_check_u32::U32RangeCheckGate, subtraction_u32::U32SubtractionGate,
        };
        use std::marker::PhantomData;
        use crate::utils::biguint::BigUintDivRemGenerator;
        pub struct DendrETHGeneratorSerializer<C: GenericConfig<D>, const D: usize> {
            pub _phantom: PhantomData<C>,
        }
        impl<F, C, const D: usize> WitnessGeneratorSerializer<F, D>
        for DendrETHGeneratorSerializer<C, D>
        where
            F: RichField + Extendable<D>,
            C: GenericConfig<D, F = F> + 'static,
            C::Hasher: AlgebraicHasher<F>,
        {
            fn read_generator(
                &self,
                buf: &mut ::plonky2::util::serialization::Buffer,
                common: &::plonky2::plonk::circuit_data::CommonCircuitData<F, D>,
            ) -> ::plonky2::util::serialization::IoResult<
                ::plonky2::iop::generator::WitnessGeneratorRef<F, D>,
            > {
                let tag = ::plonky2::util::serialization::Read::read_u32(buf)?;
                {
                    let tag = tag;
                    let buf = buf;
                    let mut i = 0..;
                    if tag == i.next().unwrap() {
                        let generator = <DummyProofGenerator<
                            F,
                            C,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ArithmeticBaseGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ArithmeticExtensionGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <BaseSplitGenerator<
                            2,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <BaseSumGenerator<
                            2,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ComparisonGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ConstantGenerator<
                            F,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <CopyGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <EqualityGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ExponentiationGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <InterpolationGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <LookupGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <LookupTableGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <LowHighGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <MulExtensionGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <NonzeroTestGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <PoseidonGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <PoseidonMdsGenerator<
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <QuotientGeneratorExtension<
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <RandomAccessGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <RandomValueGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ReducingGenerator<
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <ReducingExtensionGenerator<
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <SplitGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <WireSplitGenerator as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <BigUintDivRemGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <U32ArithmeticGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else if tag == i.next().unwrap() {
                        let generator = <U32AddManyGenerator<
                            F,
                            D,
                        > as ::plonky2::iop::generator::SimpleGenerator<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(
                            ::plonky2::iop::generator::WitnessGeneratorRef::<
                                F,
                                D,
                            >::new(
                                ::plonky2::iop::generator::SimpleGenerator::<
                                    F,
                                    D,
                                >::adapter(generator),
                            ),
                        )
                    } else {
                        Err(::plonky2::util::serialization::IoError)
                    }
                }
            }
            fn write_generator(
                &self,
                buf: &mut ::plonky2::util::serialization::generator_serialization::Vec<
                    u8,
                >,
                generator: &::plonky2::iop::generator::WitnessGeneratorRef<F, D>,
                common: &::plonky2::plonk::circuit_data::CommonCircuitData<F, D>,
            ) -> ::plonky2::util::serialization::IoResult<()> {
                let tag = {
                    let mut i = 0..;
                    if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<DummyProofGenerator<F, C, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ArithmeticBaseGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ArithmeticExtensionGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<BaseSplitGenerator<2>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<BaseSumGenerator<2>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ComparisonGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ConstantGenerator<F>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<CopyGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<EqualityGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ExponentiationGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<InterpolationGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<LookupGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<LookupTableGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<LowHighGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<MulExtensionGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<NonzeroTestGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<PoseidonGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<PoseidonMdsGenerator<D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<QuotientGeneratorExtension<D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<RandomAccessGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<RandomValueGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ReducingGenerator<D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<ReducingExtensionGenerator<D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<SplitGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<WireSplitGenerator>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<BigUintDivRemGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<U32ArithmeticGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        generator.0.id()
                            == ::plonky2::iop::generator::SimpleGenerator::<
                                F,
                                D,
                            >::id(&<U32AddManyGenerator<F, D>>::default()),
                    ) {
                        Ok(tag)
                    } else {
                        {
                            let lvl = log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "attempted to serialize generator with id {0} which is unsupported by this generator serializer",
                                        generator.0.id(),
                                    ),
                                    lvl,
                                    &(
                                        "circuits::serialization::generator_serializer",
                                        "circuits::serialization::generator_serializer",
                                        "src/serialization/generator_serializer.rs",
                                    ),
                                    63u32,
                                    (),
                                );
                            }
                        };
                        Err(::plonky2::util::serialization::IoError)
                    }
                }?;
                ::plonky2::util::serialization::Write::write_u32(buf, tag)?;
                generator.0.serialize(buf, common)?;
                Ok(())
            }
        }
        pub struct DendrETHGateSerializer;
        impl<F: RichField + Extendable<D>, const D: usize> GateSerializer<F, D>
        for DendrETHGateSerializer {
            fn read_gate(
                &self,
                buf: &mut ::plonky2::util::serialization::Buffer,
                common: &::plonky2::plonk::circuit_data::CommonCircuitData<F, D>,
            ) -> ::plonky2::util::serialization::IoResult<
                ::plonky2::gates::gate::GateRef<F, D>,
            > {
                let tag = ::plonky2::util::serialization::Read::read_u32(buf)?;
                {
                    let tag = tag;
                    let buf = buf;
                    let mut i = 0..;
                    if tag == i.next().unwrap() {
                        let gate = <ArithmeticGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ArithmeticExtensionGate<
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <BaseSumGate<
                            2,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ConstantGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <CosetInterpolationGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ExponentiationGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <LookupGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <LookupTableGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <MulExtensionGate<
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <NoopGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <PoseidonMdsGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <PoseidonGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <PublicInputGate as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <RandomAccessGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ReducingExtensionGate<
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ReducingGate<
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <U32AddManyGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <U32ArithmeticGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <U32SubtractionGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <ComparisonGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else if tag == i.next().unwrap() {
                        let gate = <U32RangeCheckGate<
                            F,
                            D,
                        > as ::plonky2::gates::gate::Gate<
                            F,
                            D,
                        >>::deserialize(buf, common)?;
                        Ok(::plonky2::gates::gate::GateRef::<F, D>::new(gate))
                    } else {
                        Err(::plonky2::util::serialization::IoError)
                    }
                }
            }
            fn write_gate(
                &self,
                buf: &mut Vec<u8>,
                gate: &::plonky2::gates::gate::GateRef<F, D>,
                common: &::plonky2::plonk::circuit_data::CommonCircuitData<F, D>,
            ) -> ::plonky2::util::serialization::IoResult<()> {
                let tag = {
                    let gate_any = gate.0.as_any();
                    let mut i = 0..;
                    if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ArithmeticGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ArithmeticExtensionGate<D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<BaseSumGate<2>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ConstantGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<CosetInterpolationGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ExponentiationGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<LookupGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<LookupTableGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<MulExtensionGate<D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<NoopGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<PoseidonMdsGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<PoseidonGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<PublicInputGate>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<RandomAccessGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ReducingExtensionGate<D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ReducingGate<D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<U32AddManyGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<U32ArithmeticGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<U32SubtractionGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<ComparisonGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else if let (tag, true) = (
                        i.next().unwrap(),
                        gate_any.is::<U32RangeCheckGate<F, D>>(),
                    ) {
                        Ok(tag)
                    } else {
                        {
                            let lvl = log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!(
                                        "attempted to serialize gate with id `{0}` which is unsupported by this gate serializer",
                                        gate.0.id(),
                                    ),
                                    lvl,
                                    &(
                                        "circuits::serialization::generator_serializer",
                                        "circuits::serialization::generator_serializer",
                                        "src/serialization/generator_serializer.rs",
                                    ),
                                    98u32,
                                    (),
                                );
                            }
                        };
                        Err(::plonky2::util::serialization::IoError)
                    }
                }?;
                ::plonky2::util::serialization::Write::write_u32(buf, tag)?;
                gate.0.serialize(buf, common)?;
                Ok(())
            }
        }
    }
    pub mod targets_serialization {
        use itertools::Itertools;
        use plonky2::util::serialization::{Buffer, IoResult, Read, Write};
        use plonky2_u32::gadgets::arithmetic_u32::U32Target;
        use crate::utils::biguint::BigUintTarget;
        pub trait ReadTargets {
            fn read_targets(data: &mut Buffer) -> IoResult<Self>
            where
                Self: Sized;
        }
        pub trait WriteTargets {
            fn write_targets(&self) -> IoResult<Vec<u8>>;
        }
        impl ReadTargets for BigUintTarget {
            fn read_targets(data: &mut Buffer) -> IoResult<Self>
            where
                Self: Sized,
            {
                Ok(BigUintTarget {
                    limbs: data
                        .read_target_vec()?
                        .iter()
                        .map(|x| U32Target(*x))
                        .collect_vec(),
                })
            }
        }
        impl WriteTargets for BigUintTarget {
            fn write_targets(&self) -> IoResult<Vec<u8>> {
                let mut data = Vec::<u8>::new();
                data.write_target_vec(&self.limbs.iter().map(|x| x.0).collect_vec())?;
                Ok(data)
            }
        }
    }
}
pub mod serializers {
    use num::BigUint;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    pub mod bool_vec_as_int_vec {
        use std::fmt;
        use serde::{
            de::{self, SeqAccess, Visitor},
            ser::SerializeSeq, Deserializer, Serializer,
        };
        pub fn serialize<S>(x: &Vec<bool>, s: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let mut seq = s.serialize_seq(Some(x.len()))?;
            for element in x {
                seq.serialize_element(&(*element as i32))?;
            }
            seq.end()
        }
        pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<bool>, D::Error>
        where
            D: Deserializer<'de>,
        {
            struct BoolVecVisitor;
            impl<'de> Visitor<'de> for BoolVecVisitor {
                type Value = Vec<bool>;
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("a sequence of 0s or 1s")
                }
                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                where
                    A: SeqAccess<'de>,
                {
                    let mut bool_vec = Vec::new();
                    while let Some(value) = seq.next_element::<i32>()? {
                        match value {
                            0 => bool_vec.push(false),
                            1 => bool_vec.push(true),
                            _ => return Err(de::Error::custom("expected 0 or 1")),
                        }
                    }
                    Ok(bool_vec)
                }
            }
            deserializer.deserialize_seq(BoolVecVisitor)
        }
        pub fn serialize_nested<S>(x: &Vec<Vec<bool>>, s: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let mut seq = s.serialize_seq(Some(x.len()))?;
            for vec in x {
                let bool_as_int_vec: Vec<i32> = vec.iter().map(|&x| x as i32).collect();
                seq.serialize_element(&bool_as_int_vec)?;
            }
            seq.end()
        }
        pub fn deserialize_nested<'de, D>(
            deserializer: D,
        ) -> Result<Vec<Vec<bool>>, D::Error>
        where
            D: Deserializer<'de>,
        {
            struct BoolVecVecVisitor;
            impl<'de> Visitor<'de> for BoolVecVecVisitor {
                type Value = Vec<Vec<bool>>;
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("a sequence of sequences of 0s or 1s")
                }
                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                where
                    A: SeqAccess<'de>,
                {
                    let mut bool_vec_vec = Vec::new();
                    while let Some(inner_vec) = seq.next_element::<Vec<i32>>()? {
                        let mut bool_vec = Vec::new();
                        for value in inner_vec {
                            match value {
                                0 => bool_vec.push(false),
                                1 => bool_vec.push(true),
                                _ => return Err(de::Error::custom("expected 0 or 1")),
                            }
                        }
                        bool_vec_vec.push(bool_vec);
                    }
                    Ok(bool_vec_vec)
                }
            }
            deserializer.deserialize_seq(BoolVecVecVisitor)
        }
    }
    pub mod bool_vec_as_int_vec_nested {
        use serde::{Deserializer, Serializer};
        use super::bool_vec_as_int_vec;
        pub fn serialize<S>(x: &Vec<Vec<bool>>, s: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            bool_vec_as_int_vec::serialize_nested(x, s)
        }
        pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<bool>>, D::Error>
        where
            D: Deserializer<'de>,
        {
            bool_vec_as_int_vec::deserialize_nested(deserializer)
        }
    }
    pub mod serde_bool_array_to_hex_string {
        use core::fmt;
        use circuit::array::Array;
        use serde::{
            de::{self, Visitor},
            Deserializer, Serializer,
        };
        use crate::utils::utils::{bits_to_bytes, bytes_to_bits};
        pub fn serialize<S, const N: usize>(
            x: &Array<bool, N>,
            s: S,
        ) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let hex_string = hex::encode(bits_to_bytes(x.as_slice()));
            s.serialize_str(&hex_string)
        }
        pub struct HexStringVisitor<const N: usize>;
        impl<'de, const N: usize> Visitor<'de> for HexStringVisitor<N> {
            type Value = Array<bool, N>;
            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str("a hex string")
            }
            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                Ok(Array(bytes_to_bits(&hex::decode(v).unwrap()).try_into().unwrap()))
            }
        }
        pub fn deserialize<'de, D, const N: usize>(
            deserializer: D,
        ) -> Result<Array<bool, N>, D::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_str(HexStringVisitor)
        }
    }
    pub mod serde_bool_array_to_hex_string_nested {
        use core::fmt;
        use circuit::array::Array;
        use serde::{
            de::{SeqAccess, Visitor},
            ser::SerializeTuple, Deserializer, Serializer,
        };
        use crate::utils::utils::{bits_to_bytes, bytes_to_bits};
        pub fn serialize<S, const N: usize, const M: usize>(
            x: &Array<Array<bool, M>, N>,
            s: S,
        ) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            let mut tup = s.serialize_tuple(N)?;
            for bits_array in x.iter() {
                let hex_string = hex::encode(bits_to_bytes(bits_array.as_slice()));
                tup.serialize_element(&hex_string)?;
            }
            tup.end()
        }
        pub fn deserialize<'de, D, const N: usize, const M: usize>(
            deserializer: D,
        ) -> Result<Array<Array<bool, M>, N>, D::Error>
        where
            D: Deserializer<'de>,
        {
            struct MultipleHexStringsVisitor<const N: usize, const M: usize>;
            impl<'de, const N: usize, const M: usize> Visitor<'de>
            for MultipleHexStringsVisitor<N, M> {
                type Value = Array<Array<bool, M>, N>;
                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("a sequence of sequences of 0s or 1s")
                }
                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                where
                    A: SeqAccess<'de>,
                {
                    Ok(
                        Array(
                            [(); N]
                                .map(|_| {
                                    let Some(hex_string) = seq.next_element::<&str>().unwrap()
                                    else {
                                        {
                                            ::core::panicking::panic_fmt(
                                                format_args!(
                                                    "Could not deserialize hex string: not enough elements",
                                                ),
                                            );
                                        };
                                    };
                                    Array(
                                        bytes_to_bits(&hex::decode(hex_string).unwrap())
                                            .try_into()
                                            .unwrap(),
                                    )
                                }),
                        ),
                    )
                }
            }
            deserializer.deserialize_seq(MultipleHexStringsVisitor)
        }
    }
    pub const VALIDATOR_REGISTRY_LIMIT: usize = 1099511627776;
    #[serde(rename_all = "camelCase")]
    pub struct ValidatorShaInput {
        pub pubkey: String,
        pub withdrawal_credentials: String,
        pub effective_balance: String,
        pub slashed: String,
        pub activation_eligibility_epoch: String,
        pub activation_epoch: String,
        pub exit_epoch: String,
        pub withdrawable_epoch: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ValidatorShaInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ValidatorShaInput",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pubkey",
                    &self.pubkey,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawalCredentials",
                    &self.withdrawal_credentials,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "effectiveBalance",
                    &self.effective_balance,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "slashed",
                    &self.slashed,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "activationEligibilityEpoch",
                    &self.activation_eligibility_epoch,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "activationEpoch",
                    &self.activation_epoch,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "exitEpoch",
                    &self.exit_epoch,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "withdrawableEpoch",
                    &self.withdrawable_epoch,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ValidatorShaInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "pubkey" => _serde::__private::Ok(__Field::__field0),
                            "withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "effectiveBalance" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "slashed" => _serde::__private::Ok(__Field::__field3),
                            "activationEligibilityEpoch" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "activationEpoch" => _serde::__private::Ok(__Field::__field5),
                            "exitEpoch" => _serde::__private::Ok(__Field::__field6),
                            "withdrawableEpoch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"pubkey" => _serde::__private::Ok(__Field::__field0),
                            b"withdrawalCredentials" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"effectiveBalance" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"slashed" => _serde::__private::Ok(__Field::__field3),
                            b"activationEligibilityEpoch" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"activationEpoch" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"exitEpoch" => _serde::__private::Ok(__Field::__field6),
                            b"withdrawableEpoch" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ValidatorShaInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ValidatorShaInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ValidatorShaInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ValidatorShaInput with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ValidatorShaInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            effective_balance: __field2,
                            slashed: __field3,
                            activation_eligibility_epoch: __field4,
                            activation_epoch: __field5,
                            exit_epoch: __field6,
                            withdrawable_epoch: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "effectiveBalance",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "slashed",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "activationEligibilityEpoch",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "activationEpoch",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "exitEpoch",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "withdrawableEpoch",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pubkey")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "withdrawalCredentials",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("effectiveBalance")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("slashed")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "activationEligibilityEpoch",
                                )?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("activationEpoch")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("exitEpoch")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("withdrawableEpoch")?
                            }
                        };
                        _serde::__private::Ok(ValidatorShaInput {
                            pubkey: __field0,
                            withdrawal_credentials: __field1,
                            effective_balance: __field2,
                            slashed: __field3,
                            activation_eligibility_epoch: __field4,
                            activation_epoch: __field5,
                            exit_epoch: __field6,
                            withdrawable_epoch: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "pubkey",
                    "withdrawalCredentials",
                    "effectiveBalance",
                    "slashed",
                    "activationEligibilityEpoch",
                    "activationEpoch",
                    "exitEpoch",
                    "withdrawableEpoch",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ValidatorShaInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ValidatorShaInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ValidatorShaInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "pubkey",
                "withdrawal_credentials",
                "effective_balance",
                "slashed",
                "activation_eligibility_epoch",
                "activation_epoch",
                "exit_epoch",
                "withdrawable_epoch",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.pubkey,
                &self.withdrawal_credentials,
                &self.effective_balance,
                &self.slashed,
                &self.activation_eligibility_epoch,
                &self.activation_epoch,
                &self.exit_epoch,
                &&self.withdrawable_epoch,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ValidatorShaInput",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ValidatorShaInput {
        #[inline]
        fn clone(&self) -> ValidatorShaInput {
            ValidatorShaInput {
                pubkey: ::core::clone::Clone::clone(&self.pubkey),
                withdrawal_credentials: ::core::clone::Clone::clone(
                    &self.withdrawal_credentials,
                ),
                effective_balance: ::core::clone::Clone::clone(&self.effective_balance),
                slashed: ::core::clone::Clone::clone(&self.slashed),
                activation_eligibility_epoch: ::core::clone::Clone::clone(
                    &self.activation_eligibility_epoch,
                ),
                activation_epoch: ::core::clone::Clone::clone(&self.activation_epoch),
                exit_epoch: ::core::clone::Clone::clone(&self.exit_epoch),
                withdrawable_epoch: ::core::clone::Clone::clone(&self.withdrawable_epoch),
            }
        }
    }
    pub fn biguint_to_str<S>(value: &BigUint, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let str_value = value.to_str_radix(10);
        serializer.serialize_str(&str_value)
    }
    pub fn parse_biguint<'de, D>(deserializer: D) -> Result<BigUint, D::Error>
    where
        D: Deserializer<'de>,
    {
        let str_value = String::deserialize(deserializer)?;
        str_value.parse::<BigUint>().map_err(serde::de::Error::custom)
    }
}
pub mod test {}
pub mod utils {
    pub mod biguint {
        use core::marker::PhantomData;
        use circuit::add_virtual_target::AddVirtualTarget;
        use circuit::public_inputs::field_reader::PublicInputsReadable;
        use circuit::public_inputs::target_reader::PublicInputsTargetReadable;
        use circuit::set_witness::SetWitness;
        use circuit::target_primitive::TargetPrimitive;
        use circuit::to_targets::ToTargets;
        use circuit::SerdeCircuitTarget;
        use itertools::Itertools;
        use num::{BigUint, Integer, Zero};
        use plonky2::field::extension::Extendable;
        use plonky2::field::types::{PrimeField, PrimeField64};
        use plonky2::hash::hash_types::RichField;
        use plonky2::iop::generator::{GeneratedValues, SimpleGenerator};
        use plonky2::iop::target::{BoolTarget, Target};
        use plonky2::iop::witness::{PartialWitness, PartitionWitness, Witness};
        use plonky2::plonk::circuit_builder::CircuitBuilder;
        use plonky2::plonk::circuit_data::CommonCircuitData;
        use plonky2::util::serialization::{Read, Write};
        use plonky2_u32::gadgets::arithmetic_u32::{CircuitBuilderU32, U32Target};
        use plonky2_u32::gadgets::multiple_comparison::list_le_u32_circuit;
        use plonky2_u32::serialization::{ReadU32, WriteU32};
        use plonky2_u32::witness::{GeneratedValuesU32, WitnessU32};
        use crate::utils::utils::biguint_target_from_limbs;
        pub struct BigUintTarget {
            pub limbs: Vec<U32Target>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BigUintTarget {
            #[inline]
            fn clone(&self) -> BigUintTarget {
                BigUintTarget {
                    limbs: ::core::clone::Clone::clone(&self.limbs),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BigUintTarget {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "BigUintTarget",
                    "limbs",
                    &&self.limbs,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for BigUintTarget {
            #[inline]
            fn default() -> BigUintTarget {
                BigUintTarget {
                    limbs: ::core::default::Default::default(),
                }
            }
        }
        impl BigUintTarget {
            pub fn num_limbs(&self) -> usize {
                self.limbs.len()
            }
            pub fn get_limb(&self, i: usize) -> U32Target {
                self.limbs[i]
            }
        }
        pub trait CircuitBuilderBiguint<F: RichField + Extendable<D>, const D: usize> {
            fn constant_biguint(&mut self, value: &BigUint) -> BigUintTarget;
            fn zero_biguint(&mut self) -> BigUintTarget;
            fn connect_biguint(&mut self, lhs: &BigUintTarget, rhs: &BigUintTarget);
            fn pad_biguints(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> (BigUintTarget, BigUintTarget);
            fn cmp_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget;
            fn gt_biguint(&mut self, a: &BigUintTarget, b: &BigUintTarget) -> BoolTarget;
            fn gte_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget;
            fn eq_biguint(&mut self, a: &BigUintTarget, b: &BigUintTarget) -> BoolTarget;
            fn lt_biguint(&mut self, a: &BigUintTarget, b: &BigUintTarget) -> BoolTarget;
            fn lte_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget;
            fn add_virtual_biguint_target(&mut self, num_limbs: usize) -> BigUintTarget;
            /// Add two `BigUintTarget`s.
            fn add_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget;
            /// Subtract two `BigUintTarget`s. We assume that the first is larger than the second.
            fn sub_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget;
            fn mul_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget;
            fn mul_biguint_by_bool(
                &mut self,
                a: &BigUintTarget,
                b: BoolTarget,
            ) -> BigUintTarget;
            /// Returns x * y + z. This is no more efficient than mul-then-add; it's purely for convenience (only need to call one CircuitBuilder function).
            fn mul_add_biguint(
                &mut self,
                x: &BigUintTarget,
                y: &BigUintTarget,
                z: &BigUintTarget,
            ) -> BigUintTarget;
            fn div_rem_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> (BigUintTarget, BigUintTarget);
            fn div_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget;
            fn rem_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget;
        }
        impl<F: RichField> SetWitness<F> for BigUintTarget {
            type Input = <Self as TargetPrimitive>::Primitive;
            fn set_witness(&self, witness: &mut PartialWitness<F>, input: &Self::Input) {
                witness.set_biguint_target(self, input);
            }
        }
        impl<F: RichField + Extendable<D>, const D: usize> CircuitBuilderBiguint<F, D>
        for CircuitBuilder<F, D> {
            fn constant_biguint(&mut self, value: &BigUint) -> BigUintTarget {
                let limb_values = value.to_u32_digits();
                let limbs = limb_values.iter().map(|&l| self.constant_u32(l)).collect();
                BigUintTarget { limbs }
            }
            fn zero_biguint(&mut self) -> BigUintTarget {
                self.constant_biguint(&BigUint::zero())
            }
            fn connect_biguint(&mut self, lhs: &BigUintTarget, rhs: &BigUintTarget) {
                let min_limbs = lhs.num_limbs().min(rhs.num_limbs());
                for i in 0..min_limbs {
                    self.connect_u32(lhs.get_limb(i), rhs.get_limb(i));
                }
                for i in min_limbs..lhs.num_limbs() {
                    self.assert_zero_u32(lhs.get_limb(i));
                }
                for i in min_limbs..rhs.num_limbs() {
                    self.assert_zero_u32(rhs.get_limb(i));
                }
            }
            fn pad_biguints(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> (BigUintTarget, BigUintTarget) {
                if a.num_limbs() > b.num_limbs() {
                    let mut padded_b = b.clone();
                    for _ in b.num_limbs()..a.num_limbs() {
                        padded_b.limbs.push(self.zero_u32());
                    }
                    (a.clone(), padded_b)
                } else {
                    let mut padded_a = a.clone();
                    for _ in a.num_limbs()..b.num_limbs() {
                        padded_a.limbs.push(self.zero_u32());
                    }
                    (padded_a, b.clone())
                }
            }
            fn cmp_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                let (a, b) = self.pad_biguints(a, b);
                list_le_u32_circuit(self, a.limbs, b.limbs)
            }
            fn gt_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                let a_lte_b_pred = self.cmp_biguint(a, b);
                self.not(a_lte_b_pred)
            }
            fn gte_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                let a_gt_b_pred = self.gt_biguint(a, b);
                let a_equal_to_b_pred = self.eq_biguint(a, b);
                self.or(a_gt_b_pred, a_equal_to_b_pred)
            }
            fn eq_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                let (a, b) = self.pad_biguints(a, b);
                a.limbs
                    .iter()
                    .zip(b.limbs)
                    .fold(
                        self._false(),
                        |acc, (a_limb, b_limb)| {
                            let a_limb_eq_to_b_limb_pred = self
                                .is_equal(a_limb.0, b_limb.0);
                            self.and(acc, a_limb_eq_to_b_limb_pred)
                        },
                    )
            }
            fn lt_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                let a_lte_b_pred = self.cmp_biguint(a, b);
                let a_eq_to_b_pred = self.eq_biguint(a, b);
                let a_not_eq_to_b_pred = self.not(a_eq_to_b_pred);
                self.and(a_lte_b_pred, a_not_eq_to_b_pred)
            }
            fn lte_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BoolTarget {
                self.cmp_biguint(a, b)
            }
            fn add_virtual_biguint_target(&mut self, num_limbs: usize) -> BigUintTarget {
                let limbs = self.add_virtual_u32_targets(num_limbs);
                BigUintTarget { limbs }
            }
            fn add_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget {
                let num_limbs = a.num_limbs().max(b.num_limbs());
                let mut combined_limbs = ::alloc::vec::Vec::new();
                let mut carry = self.zero_u32();
                for i in 0..num_limbs {
                    let a_limb = (i < a.num_limbs())
                        .then(|| a.limbs[i])
                        .unwrap_or_else(|| self.zero_u32());
                    let b_limb = (i < b.num_limbs())
                        .then(|| b.limbs[i])
                        .unwrap_or_else(|| self.zero_u32());
                    let (new_limb, new_carry) = self
                        .add_many_u32(&[carry, a_limb, b_limb]);
                    carry = new_carry;
                    combined_limbs.push(new_limb);
                }
                combined_limbs.push(carry);
                BigUintTarget {
                    limbs: combined_limbs,
                }
            }
            fn sub_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget {
                let (a, b) = self.pad_biguints(a, b);
                let num_limbs = a.limbs.len();
                let mut result_limbs = ::alloc::vec::Vec::new();
                let mut borrow = self.zero_u32();
                for i in 0..num_limbs {
                    let (result, new_borrow) = self
                        .sub_u32(a.limbs[i], b.limbs[i], borrow);
                    result_limbs.push(result);
                    borrow = new_borrow;
                }
                BigUintTarget {
                    limbs: result_limbs,
                }
            }
            fn mul_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget {
                let total_limbs = a.limbs.len() + b.limbs.len();
                let mut to_add = ::alloc::vec::from_elem(
                    ::alloc::vec::Vec::new(),
                    total_limbs,
                );
                for i in 0..a.limbs.len() {
                    for j in 0..b.limbs.len() {
                        let (product, carry) = self.mul_u32(a.limbs[i], b.limbs[j]);
                        to_add[i + j].push(product);
                        to_add[i + j + 1].push(carry);
                    }
                }
                let mut combined_limbs = ::alloc::vec::Vec::new();
                let mut carry = self.zero_u32();
                for summands in &mut to_add {
                    let (new_result, new_carry) = self
                        .add_u32s_with_carry(summands, carry);
                    combined_limbs.push(new_result);
                    carry = new_carry;
                }
                combined_limbs.push(carry);
                BigUintTarget {
                    limbs: combined_limbs,
                }
            }
            fn mul_biguint_by_bool(
                &mut self,
                a: &BigUintTarget,
                b: BoolTarget,
            ) -> BigUintTarget {
                let t = b.target;
                BigUintTarget {
                    limbs: a.limbs.iter().map(|&l| U32Target(self.mul(l.0, t))).collect(),
                }
            }
            fn mul_add_biguint(
                &mut self,
                x: &BigUintTarget,
                y: &BigUintTarget,
                z: &BigUintTarget,
            ) -> BigUintTarget {
                let prod = self.mul_biguint(x, y);
                self.add_biguint(&prod, z)
            }
            fn div_rem_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> (BigUintTarget, BigUintTarget) {
                let a_len = a.limbs.len();
                let b_len = b.limbs.len();
                let div_num_limbs = if b_len > a_len + 1 {
                    0
                } else {
                    a_len - b_len + 1
                };
                let div = self.add_virtual_biguint_target(div_num_limbs);
                let rem = self.add_virtual_biguint_target(b_len);
                self.add_simple_generator(BigUintDivRemGenerator::<F, D> {
                    a: a.clone(),
                    b: b.clone(),
                    div: div.clone(),
                    rem: rem.clone(),
                    _phantom: PhantomData,
                });
                let div_b = self.mul_biguint(&div, b);
                let div_b_plus_rem = self.add_biguint(&div_b, &rem);
                self.connect_biguint(a, &div_b_plus_rem);
                let cmp_rem_b = self.cmp_biguint(&rem, b);
                self.assert_one(cmp_rem_b.target);
                (div, rem)
            }
            fn div_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget {
                let (div, _rem) = self.div_rem_biguint(a, b);
                div
            }
            fn rem_biguint(
                &mut self,
                a: &BigUintTarget,
                b: &BigUintTarget,
            ) -> BigUintTarget {
                let (_div, rem) = self.div_rem_biguint(a, b);
                rem
            }
        }
        impl TargetPrimitive for BigUintTarget {
            type Primitive = BigUint;
        }
        impl ToTargets for BigUintTarget {
            fn to_targets(&self) -> Vec<Target> {
                match (&self.limbs.len(), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                self.limbs.iter().map(|limb| limb.0).collect_vec()
            }
        }
        impl PublicInputsReadable for BigUintTarget {
            fn from_elements<F: RichField>(elements: &[F]) -> Self::Primitive {
                match (&elements.len(), &Self::get_size()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let first_limb = elements[0].to_canonical_u64();
                let second_limb = elements[1].to_canonical_u64();
                if !(first_limb < (2 << 32)) {
                    ::core::panicking::panic("assertion failed: first_limb < (2 << 32)")
                }
                if !(second_limb < (2 << 32)) {
                    ::core::panicking::panic("assertion failed: second_limb < (2 << 32)")
                }
                BigUint::from(first_limb + (second_limb << 32))
            }
        }
        impl PublicInputsTargetReadable for BigUintTarget {
            fn get_size() -> usize {
                2
            }
            fn from_targets(targets: &[Target]) -> Self {
                match (&targets.len(), &Self::get_size()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                biguint_target_from_limbs(targets)
            }
        }
        impl AddVirtualTarget for BigUintTarget {
            fn add_virtual_target<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
            ) -> Self {
                builder.add_virtual_biguint_target(2)
            }
        }
        pub trait WitnessBigUint<F: PrimeField64>: Witness<F> {
            fn get_biguint_target(&self, target: BigUintTarget) -> BigUint;
            fn set_biguint_target(&mut self, target: &BigUintTarget, value: &BigUint);
        }
        impl SerdeCircuitTarget for BigUintTarget {
            fn serialize(&self) -> plonky2::util::serialization::IoResult<Vec<u8>> {
                match (&self.num_limbs(), &2) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                let mut buffer: Vec<u8> = Vec::new();
                buffer.write_target(self.limbs[0].0)?;
                buffer.write_target(self.limbs[1].0)?;
                Ok(buffer)
            }
            fn deserialize(
                buffer: &mut plonky2::util::serialization::Buffer,
            ) -> plonky2::util::serialization::IoResult<Self>
            where
                Self: Sized,
            {
                let first_limb = buffer.read_target()?;
                let second_limb = buffer.read_target()?;
                Ok(BigUintTarget::from_targets(&[first_limb, second_limb]))
            }
        }
        impl<T: Witness<F>, F: PrimeField64> WitnessBigUint<F> for T {
            fn get_biguint_target(&self, target: BigUintTarget) -> BigUint {
                target
                    .limbs
                    .into_iter()
                    .rev()
                    .fold(
                        BigUint::zero(),
                        |acc, limb| {
                            (acc << 32) + self.get_target(limb.0).to_canonical_biguint()
                        },
                    )
            }
            fn set_biguint_target(&mut self, target: &BigUintTarget, value: &BigUint) {
                let mut limbs = value.to_u32_digits();
                if !(target.num_limbs() >= limbs.len()) {
                    ::core::panicking::panic(
                        "assertion failed: target.num_limbs() >= limbs.len()",
                    )
                }
                limbs.resize(target.num_limbs(), 0);
                for i in 0..target.num_limbs() {
                    self.set_u32_target(target.limbs[i], limbs[i]);
                }
            }
        }
        pub trait GeneratedValuesBigUint<F: PrimeField> {
            fn set_biguint_target(&mut self, target: &BigUintTarget, value: &BigUint);
        }
        impl<F: PrimeField> GeneratedValuesBigUint<F> for GeneratedValues<F> {
            fn set_biguint_target(&mut self, target: &BigUintTarget, value: &BigUint) {
                let mut limbs = value.to_u32_digits();
                if !(target.num_limbs() >= limbs.len()) {
                    ::core::panicking::panic(
                        "assertion failed: target.num_limbs() >= limbs.len()",
                    )
                }
                limbs.resize(target.num_limbs(), 0);
                for i in 0..target.num_limbs() {
                    self.set_u32_target(target.get_limb(i), limbs[i]);
                }
            }
        }
        pub struct BigUintDivRemGenerator<F: RichField + Extendable<D>, const D: usize> {
            a: BigUintTarget,
            b: BigUintTarget,
            div: BigUintTarget,
            rem: BigUintTarget,
            _phantom: PhantomData<F>,
        }
        #[automatically_derived]
        impl<
            F: ::core::fmt::Debug + RichField + Extendable<D>,
            const D: usize,
        > ::core::fmt::Debug for BigUintDivRemGenerator<F, D> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "BigUintDivRemGenerator",
                    "a",
                    &self.a,
                    "b",
                    &self.b,
                    "div",
                    &self.div,
                    "rem",
                    &self.rem,
                    "_phantom",
                    &&self._phantom,
                )
            }
        }
        #[automatically_derived]
        impl<
            F: ::core::default::Default + RichField + Extendable<D>,
            const D: usize,
        > ::core::default::Default for BigUintDivRemGenerator<F, D> {
            #[inline]
            fn default() -> BigUintDivRemGenerator<F, D> {
                BigUintDivRemGenerator {
                    a: ::core::default::Default::default(),
                    b: ::core::default::Default::default(),
                    div: ::core::default::Default::default(),
                    rem: ::core::default::Default::default(),
                    _phantom: ::core::default::Default::default(),
                }
            }
        }
        impl<F: RichField + Extendable<D>, const D: usize> SimpleGenerator<F, D>
        for BigUintDivRemGenerator<F, D> {
            fn dependencies(&self) -> Vec<Target> {
                self.a.limbs.iter().chain(&self.b.limbs).map(|&l| l.0).collect()
            }
            fn run_once(
                &self,
                witness: &PartitionWitness<F>,
                out_buffer: &mut GeneratedValues<F>,
            ) {
                let a = witness.get_biguint_target(self.a.clone());
                let b = witness.get_biguint_target(self.b.clone());
                let (div, rem) = a.div_rem(&b);
                out_buffer.set_biguint_target(&self.div, &div);
                out_buffer.set_biguint_target(&self.rem, &rem);
            }
            fn id(&self) -> String {
                "BigUintDivRemGenerator".to_string()
            }
            fn serialize(
                &self,
                dst: &mut Vec<u8>,
                _common_data: &CommonCircuitData<F, D>,
            ) -> plonky2::util::serialization::IoResult<()> {
                dst.write_usize(self.a.num_limbs())?;
                for i in 0..self.a.num_limbs() {
                    dst.write_target_u32(self.a.limbs[i])?;
                }
                dst.write_usize(self.b.num_limbs())?;
                for i in 0..self.b.num_limbs() {
                    dst.write_target_u32(self.b.limbs[i])?;
                }
                dst.write_usize(self.div.num_limbs())?;
                for i in 0..self.div.num_limbs() {
                    dst.write_target_u32(self.div.limbs[i])?;
                }
                dst.write_usize(self.rem.num_limbs())?;
                for i in 0..self.rem.num_limbs() - 1 {
                    dst.write_target_u32(self.rem.limbs[i])?;
                }
                dst.write_target_u32(self.rem.limbs[self.rem.num_limbs() - 1])
            }
            fn deserialize(
                src: &mut plonky2::util::serialization::Buffer,
                _common_data: &CommonCircuitData<F, D>,
            ) -> plonky2::util::serialization::IoResult<Self>
            where
                Self: Sized,
            {
                let a_size = src.read_usize()?;
                let mut a_limbs: Vec<U32Target> = Vec::new();
                for _i in 0..a_size {
                    a_limbs.push(src.read_target_u32()?);
                }
                let b_size = src.read_usize()?;
                let mut b_limbs: Vec<U32Target> = Vec::new();
                for _i in 0..b_size {
                    b_limbs.push(src.read_target_u32()?);
                }
                let div_size = src.read_usize()?;
                let mut div_limbs: Vec<U32Target> = Vec::new();
                for _i in 0..div_size {
                    div_limbs.push(src.read_target_u32()?);
                }
                let rem_size = src.read_usize()?;
                let mut rem_limbs: Vec<U32Target> = Vec::new();
                for _i in 0..rem_size {
                    rem_limbs.push(src.read_target_u32()?);
                }
                Ok(Self {
                    a: BigUintTarget { limbs: a_limbs },
                    b: BigUintTarget { limbs: b_limbs },
                    div: BigUintTarget { limbs: div_limbs },
                    rem: BigUintTarget { limbs: rem_limbs },
                    _phantom: PhantomData,
                })
            }
        }
    }
    pub mod hashing {
        pub mod hash_tree_root {
            use plonky2::{
                field::extension::Extendable, hash::hash_types::RichField,
                iop::target::BoolTarget, plonk::circuit_builder::CircuitBuilder,
            };
            use crate::{
                common_targets::{SSZLeafTarget, Sha256Target},
                utils::utils::{create_bool_target_array, ETH_SHA256_BIT_SIZE},
            };
            use super::sha256::{make_circuits, Sha256Targets};
            pub struct HashTreeRootTargets {
                pub leaves: Vec<[BoolTarget; ETH_SHA256_BIT_SIZE]>,
                pub hash_tree_root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            }
            pub fn hash_tree_root_new<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                leaves: &[SSZLeafTarget],
            ) -> Sha256Target {
                if !leaves.len().is_power_of_two() {
                    ::core::panicking::panic(
                        "assertion failed: leaves.len().is_power_of_two()",
                    )
                }
                let mut hashers: Vec<Sha256Targets> = Vec::new();
                for i in 0..(leaves.len() / 2) {
                    hashers.push(make_circuits(builder, 2 * ETH_SHA256_BIT_SIZE as u64));
                    for j in 0..ETH_SHA256_BIT_SIZE {
                        builder
                            .connect(
                                hashers[i].message[j].target,
                                leaves[i * 2][j].target,
                            );
                        builder
                            .connect(
                                hashers[i].message[j + 256].target,
                                leaves[i * 2 + 1][j].target,
                            );
                    }
                }
                let mut k = 0;
                for i in leaves.len() / 2..leaves.len() - 1 {
                    hashers.push(make_circuits(builder, 2 * ETH_SHA256_BIT_SIZE as u64));
                    for j in 0..ETH_SHA256_BIT_SIZE {
                        builder
                            .connect(
                                hashers[i].message[j].target,
                                hashers[k * 2].digest[j].target,
                            );
                        builder
                            .connect(
                                hashers[i].message[j + ETH_SHA256_BIT_SIZE].target,
                                hashers[k * 2 + 1].digest[j].target,
                            );
                    }
                    k += 1;
                }
                hashers[leaves.len() - 2].digest.clone().try_into().unwrap()
            }
            pub fn hash_tree_root<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                leaves_len: usize,
            ) -> HashTreeRootTargets {
                let leaves: Vec<[BoolTarget; ETH_SHA256_BIT_SIZE]> = (0..leaves_len)
                    .map(|_| create_bool_target_array(builder))
                    .collect();
                let mut hashers: Vec<Sha256Targets> = Vec::new();
                for i in 0..(leaves_len / 2) {
                    hashers.push(make_circuits(builder, 2 * ETH_SHA256_BIT_SIZE as u64));
                    for j in 0..ETH_SHA256_BIT_SIZE {
                        builder
                            .connect(
                                hashers[i].message[j].target,
                                leaves[i * 2][j].target,
                            );
                        builder
                            .connect(
                                hashers[i].message[j + 256].target,
                                leaves[i * 2 + 1][j].target,
                            );
                    }
                }
                let mut k = 0;
                for i in leaves_len / 2..leaves_len - 1 {
                    hashers.push(make_circuits(builder, 2 * ETH_SHA256_BIT_SIZE as u64));
                    for j in 0..ETH_SHA256_BIT_SIZE {
                        builder
                            .connect(
                                hashers[i].message[j].target,
                                hashers[k * 2].digest[j].target,
                            );
                        builder
                            .connect(
                                hashers[i].message[j + ETH_SHA256_BIT_SIZE].target,
                                hashers[k * 2 + 1].digest[j].target,
                            );
                    }
                    k += 1;
                }
                HashTreeRootTargets {
                    leaves,
                    hash_tree_root: hashers[leaves_len - 2]
                        .digest
                        .clone()
                        .try_into()
                        .unwrap(),
                }
            }
        }
        pub mod hash_tree_root_poseidon {
            use plonky2::{
                field::extension::Extendable,
                hash::{
                    hash_types::{HashOutTarget, RichField},
                    poseidon::PoseidonHash,
                },
                plonk::circuit_builder::CircuitBuilder,
            };
            pub struct HashTreeRootPoseidonTargets {
                pub leaves: Vec<HashOutTarget>,
                pub hash_tree_root: HashOutTarget,
            }
            pub fn hash_tree_root_poseidon_new<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                leaves: &[HashOutTarget],
            ) -> HashOutTarget {
                if !leaves.len().is_power_of_two() {
                    ::core::panicking::panic(
                        "assertion failed: leaves.len().is_power_of_two()",
                    )
                }
                let mut hashers: Vec<HashOutTarget> = Vec::new();
                for i in 0..(leaves.len() / 2) {
                    let hash_target = builder
                        .hash_n_to_hash_no_pad::<
                            PoseidonHash,
                        >(
                            leaves[i * 2]
                                .elements
                                .iter()
                                .copied()
                                .chain(leaves[i * 2 + 1].elements.iter().copied())
                                .collect(),
                        );
                    hashers.push(hash_target);
                }
                let mut k = 0;
                for _ in leaves.len() / 2..leaves.len() - 1 {
                    hashers
                        .push(
                            builder
                                .hash_n_to_hash_no_pad::<
                                    PoseidonHash,
                                >(
                                    hashers[k * 2]
                                        .elements
                                        .iter()
                                        .copied()
                                        .chain(hashers[k * 2 + 1].elements.iter().copied())
                                        .collect(),
                                ),
                        );
                    k += 1;
                }
                hashers[leaves.len() - 2]
            }
            pub fn hash_tree_root_poseidon<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                leaves_len: usize,
            ) -> HashTreeRootPoseidonTargets {
                let leaves: Vec<HashOutTarget> = (0..leaves_len)
                    .map(|_| builder.add_virtual_hash())
                    .collect();
                let mut hashers: Vec<HashOutTarget> = Vec::new();
                for i in 0..(leaves_len / 2) {
                    let hash_target = builder
                        .hash_n_to_hash_no_pad::<
                            PoseidonHash,
                        >(
                            leaves[i * 2]
                                .elements
                                .iter()
                                .copied()
                                .chain(leaves[i * 2 + 1].elements.iter().copied())
                                .collect(),
                        );
                    hashers.push(hash_target);
                }
                let mut k = 0;
                for _ in leaves_len / 2..leaves_len - 1 {
                    hashers
                        .push(
                            builder
                                .hash_n_to_hash_no_pad::<
                                    PoseidonHash,
                                >(
                                    hashers[k * 2]
                                        .elements
                                        .iter()
                                        .copied()
                                        .chain(hashers[k * 2 + 1].elements.iter().copied())
                                        .collect(),
                                ),
                        );
                    k += 1;
                }
                HashTreeRootPoseidonTargets {
                    leaves,
                    hash_tree_root: hashers[leaves_len - 2],
                }
            }
        }
        pub mod is_valid_merkle_branch {
            use plonky2::{
                field::extension::Extendable, hash::hash_types::RichField,
                iop::target::{BoolTarget, Target},
                plonk::circuit_builder::CircuitBuilder,
                util::serialization::{Buffer, IoResult, Read, Write},
            };
            use crate::{
                serialization::targets_serialization::{ReadTargets, WriteTargets},
                utils::{
                    biguint::BigUintTarget,
                    utils::{
                        biguint_to_le_bits_target, create_bool_target_array,
                        ETH_SHA256_BIT_SIZE,
                    },
                },
            };
            use super::sha256::{bool_arrays_are_equal, make_circuits, sha256_pair};
            pub struct IsValidMerkleBranchTargets {
                pub leaf: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub branch: Vec<[BoolTarget; ETH_SHA256_BIT_SIZE]>,
                pub index: Target,
                pub root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            }
            pub struct IsValidMerkleBranchTargetsResult {
                pub leaf: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub branch: Vec<[BoolTarget; ETH_SHA256_BIT_SIZE]>,
                pub index: Target,
                pub root: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub is_valid: BoolTarget,
            }
            pub type Sha256 = [BoolTarget; ETH_SHA256_BIT_SIZE];
            pub type MerkleBranch<const DEPTH: usize> = [Sha256; DEPTH];
            impl<const DEPTH: usize> ReadTargets for MerkleBranch<DEPTH> {
                fn read_targets(data: &mut Buffer) -> IoResult<MerkleBranch<DEPTH>> {
                    let depth = data.read_usize()?;
                    match (&depth, &DEPTH) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                    let branch = [(); DEPTH]
                        .map(|_| {
                            data.read_target_bool_vec().unwrap().try_into().unwrap()
                        });
                    Ok(branch)
                }
            }
            impl<const DEPTH: usize> WriteTargets for MerkleBranch<DEPTH> {
                fn write_targets(&self) -> IoResult<Vec<u8>> {
                    let mut data: Vec<u8> = Vec::new();
                    data.write_usize(DEPTH)?;
                    for witness in self {
                        if !(witness.len() == ETH_SHA256_BIT_SIZE) {
                            ::core::panicking::panic(
                                "assertion failed: witness.len() == ETH_SHA256_BIT_SIZE",
                            )
                        }
                        data.write_target_bool_vec(witness)?;
                    }
                    Ok(data)
                }
            }
            pub fn pick_left_and_right_hash<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                current_node: Sha256,
                sibling: Sha256,
                merkle_path_bit: BoolTarget,
            ) -> (Sha256, Sha256) {
                let mut left = Vec::new();
                let mut right = Vec::new();
                for idx in 0..ETH_SHA256_BIT_SIZE {
                    left.push(
                        BoolTarget::new_unsafe(
                            builder
                                ._if(
                                    merkle_path_bit,
                                    sibling[idx].target,
                                    current_node[idx].target,
                                ),
                        ),
                    );
                    right
                        .push(
                            BoolTarget::new_unsafe(
                                builder
                                    ._if(
                                        merkle_path_bit,
                                        current_node[idx].target,
                                        sibling[idx].target,
                                    ),
                            ),
                        );
                }
                (left.try_into().unwrap(), right.try_into().unwrap())
            }
            pub fn restore_merkle_root<
                const DEPTH: usize,
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                leaf: &Sha256,
                branch: &MerkleBranch<DEPTH>,
                gindex: &BigUintTarget,
            ) -> Sha256 {
                let bits = biguint_to_le_bits_target::<F, D, 2>(builder, &gindex);
                let mut current = leaf.clone();
                for level in 0..DEPTH {
                    let (left_hash, right_hash) = pick_left_and_right_hash(
                        builder,
                        current,
                        branch[level],
                        bits[level],
                    );
                    current = sha256_pair(
                        builder,
                        left_hash.as_slice(),
                        right_hash.as_slice(),
                    );
                }
                current
            }
            pub fn validate_merkle_proof<
                const DEPTH: usize,
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                leaf: &Sha256,
                root: &Sha256,
                branch: &MerkleBranch<DEPTH>,
                gindex: &BigUintTarget,
            ) -> BoolTarget {
                let restored_root = restore_merkle_root(builder, leaf, branch, gindex);
                bool_arrays_are_equal(builder, root, &restored_root)
            }
            pub fn assert_merkle_proof_is_valid<
                const DEPTH: usize,
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                leaf: &Sha256,
                root: &Sha256,
                branch: &MerkleBranch<DEPTH>,
                gindex: &BigUintTarget,
            ) {
                let is_valid = validate_merkle_proof(
                    builder,
                    leaf,
                    root,
                    branch,
                    gindex,
                );
                let _true = builder._true();
                builder.connect(is_valid.target, _true.target);
            }
            pub fn is_valid_merkle_branch_sha256_result<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                depth: usize,
            ) -> IsValidMerkleBranchTargetsResult {
                let index = builder.add_virtual_target();
                let leaf: [BoolTarget; ETH_SHA256_BIT_SIZE] = create_bool_target_array(
                    builder,
                );
                let branch: Vec<[BoolTarget; ETH_SHA256_BIT_SIZE]> = (0..depth)
                    .map(|_| create_bool_target_array(builder))
                    .collect();
                let root: [BoolTarget; ETH_SHA256_BIT_SIZE] = create_bool_target_array(
                    builder,
                );
                let indexes = builder.split_le(index, depth + 1);
                let mut hashers = Vec::new();
                for i in 0..depth {
                    hashers
                        .push(make_circuits(builder, (2 * ETH_SHA256_BIT_SIZE) as u64));
                    let current: [BoolTarget; ETH_SHA256_BIT_SIZE] = if i == 0 {
                        leaf
                    } else {
                        hashers[i - 1].digest.clone().try_into().unwrap()
                    };
                    for j in 0..ETH_SHA256_BIT_SIZE {
                        let el1 = builder
                            ._if(indexes[i], branch[i][j].target, current[j].target);
                        builder.connect(hashers[i].message[j].target, el1);
                        let el2 = builder
                            ._if(indexes[i], current[j].target, branch[i][j].target);
                        builder
                            .connect(
                                hashers[i].message[j + ETH_SHA256_BIT_SIZE].target,
                                el2,
                            );
                    }
                }
                let mut is_valid = builder._true();
                for i in 0..ETH_SHA256_BIT_SIZE {
                    let is_equal = builder
                        .is_equal(hashers[depth - 1].digest[i].target, root[i].target);
                    is_valid = builder.and(is_valid, is_equal);
                }
                IsValidMerkleBranchTargetsResult {
                    leaf,
                    branch,
                    index,
                    root,
                    is_valid,
                }
            }
            pub fn is_valid_merkle_branch_sha256<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                depth: usize,
            ) -> IsValidMerkleBranchTargets {
                let is_valid_merkle_branch_result_targets = is_valid_merkle_branch_sha256_result(
                    builder,
                    depth,
                );
                let _true = builder._true();
                builder
                    .connect(
                        is_valid_merkle_branch_result_targets.is_valid.target,
                        _true.target,
                    );
                IsValidMerkleBranchTargets {
                    leaf: is_valid_merkle_branch_result_targets.leaf,
                    branch: is_valid_merkle_branch_result_targets.branch,
                    index: is_valid_merkle_branch_result_targets.index,
                    root: is_valid_merkle_branch_result_targets.root,
                }
            }
        }
        pub mod is_valid_merkle_branch_poseidon {
            use plonky2::{
                field::extension::Extendable,
                hash::{
                    hash_types::{HashOutTarget, RichField, NUM_HASH_OUT_ELTS},
                    poseidon::PoseidonHash,
                },
                iop::target::{BoolTarget, Target},
                plonk::circuit_builder::CircuitBuilder,
            };
            pub struct IsValidMerkleBranchTargetsPoseidon {
                pub leaf: HashOutTarget,
                pub branch: Vec<HashOutTarget>,
                pub index: Target,
                pub root: HashOutTarget,
            }
            pub struct IsValidMerkleBranchTargetsPoseidonResult {
                pub leaf: HashOutTarget,
                pub branch: Vec<HashOutTarget>,
                pub index: Target,
                pub root: HashOutTarget,
                pub is_valid: BoolTarget,
            }
            pub fn is_valid_merkle_branch_poseidon_result<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                depth: usize,
            ) -> IsValidMerkleBranchTargetsPoseidonResult {
                let index = builder.add_virtual_target();
                let leaf: HashOutTarget = builder.add_virtual_hash();
                let branch: Vec<HashOutTarget> = (0..depth)
                    .map(|_| builder.add_virtual_hash())
                    .collect();
                let root: HashOutTarget = builder.add_virtual_hash();
                let indexes = builder.split_le(index, depth + 1);
                let mut hashers: Vec<HashOutTarget> = Vec::new();
                for i in 0..depth {
                    let current: HashOutTarget = if i == 0 {
                        leaf
                    } else {
                        hashers[i - 1]
                    };
                    for j in 0..NUM_HASH_OUT_ELTS {
                        let el1 = builder
                            ._if(indexes[i], branch[i].elements[j], current.elements[j]);
                        let el2 = builder
                            ._if(indexes[i], current.elements[j], branch[i].elements[j]);
                        hashers
                            .push(
                                builder
                                    .hash_n_to_hash_no_pad::<
                                        PoseidonHash,
                                    >(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([el1, el2]),
                                        ),
                                    ),
                            );
                    }
                }
                let mut is_valid = builder._true();
                for i in 0..NUM_HASH_OUT_ELTS {
                    let is_equal = builder
                        .is_equal(hashers[depth - 1].elements[i], root.elements[i]);
                    is_valid = builder.and(is_valid, is_equal);
                }
                IsValidMerkleBranchTargetsPoseidonResult {
                    leaf: leaf,
                    branch: branch,
                    index: index,
                    root: root,
                    is_valid,
                }
            }
            pub fn is_valid_merkle_branch_sha256<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                depth: usize,
            ) -> IsValidMerkleBranchTargetsPoseidon {
                let is_valid_merkle_branch_result_targets = is_valid_merkle_branch_poseidon_result(
                    builder,
                    depth,
                );
                let _true = builder._true();
                builder
                    .connect(
                        is_valid_merkle_branch_result_targets.is_valid.target,
                        _true.target,
                    );
                IsValidMerkleBranchTargetsPoseidon {
                    leaf: is_valid_merkle_branch_result_targets.leaf,
                    branch: is_valid_merkle_branch_result_targets.branch,
                    index: is_valid_merkle_branch_result_targets.index,
                    root: is_valid_merkle_branch_result_targets.root,
                }
            }
        }
        pub mod poseidon {
            use plonky2::{
                field::extension::Extendable,
                hash::{
                    hash_types::{HashOutTarget, RichField},
                    poseidon::PoseidonHash,
                },
                iop::target::Target, plonk::circuit_builder::CircuitBuilder,
            };
            pub fn hash_poseidon<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                targets: Vec<Target>,
            ) -> HashOutTarget {
                builder.hash_n_to_hash_no_pad::<PoseidonHash>(targets)
            }
            pub fn poseidon_pair<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                left: HashOutTarget,
                right: HashOutTarget,
            ) -> HashOutTarget {
                builder
                    .hash_n_to_hash_no_pad::<
                        PoseidonHash,
                    >(
                        left
                            .elements
                            .iter()
                            .chain(right.elements.iter())
                            .cloned()
                            .collect(),
                    )
            }
        }
        pub mod sha256 {
            use itertools::Itertools;
            use plonky2::hash::hash_types::RichField;
            use plonky2::iop::target::BoolTarget;
            use plonky2::plonk::circuit_builder::CircuitBuilder;
            use plonky2::{field::extension::Extendable, iop::target::Target};
            use plonky2_u32::gadgets::arithmetic_u32::{CircuitBuilderU32, U32Target};
            use super::is_valid_merkle_branch::Sha256;
            #[rustfmt::skip]
            pub const H256: [u32; 8] = [
                0x6a09e667,
                0xbb67ae85,
                0x3c6ef372,
                0xa54ff53a,
                0x510e527f,
                0x9b05688c,
                0x1f83d9ab,
                0x5be0cd19,
            ];
            /// Constants necessary for SHA-256 family of digests.
            #[rustfmt::skip]
            pub const K256: [u32; 64] = [
                0x428A2F98,
                0x71374491,
                0xB5C0FBCF,
                0xE9B5DBA5,
                0x3956C25B,
                0x59F111F1,
                0x923F82A4,
                0xAB1C5ED5,
                0xD807AA98,
                0x12835B01,
                0x243185BE,
                0x550C7DC3,
                0x72BE5D74,
                0x80DEB1FE,
                0x9BDC06A7,
                0xC19BF174,
                0xE49B69C1,
                0xEFBE4786,
                0x0FC19DC6,
                0x240CA1CC,
                0x2DE92C6F,
                0x4A7484AA,
                0x5CB0A9DC,
                0x76F988DA,
                0x983E5152,
                0xA831C66D,
                0xB00327C8,
                0xBF597FC7,
                0xC6E00BF3,
                0xD5A79147,
                0x06CA6351,
                0x14292967,
                0x27B70A85,
                0x2E1B2138,
                0x4D2C6DFC,
                0x53380D13,
                0x650A7354,
                0x766A0ABB,
                0x81C2C92E,
                0x92722C85,
                0xA2BFE8A1,
                0xA81A664B,
                0xC24B8B70,
                0xC76C51A3,
                0xD192E819,
                0xD6990624,
                0xF40E3585,
                0x106AA070,
                0x19A4C116,
                0x1E376C08,
                0x2748774C,
                0x34B0BCB5,
                0x391C0CB3,
                0x4ED8AA4A,
                0x5B9CCA4F,
                0x682E6FF3,
                0x748F82EE,
                0x78A5636F,
                0x84C87814,
                0x8CC70208,
                0x90BEFFFA,
                0xA4506CEB,
                0xBEF9A3F7,
                0xC67178F2,
            ];
            pub struct Sha256Targets {
                pub message: Vec<BoolTarget>,
                pub digest: Vec<BoolTarget>,
            }
            pub fn array_to_bits(bytes: &[u8]) -> Vec<bool> {
                let len = bytes.len();
                let mut ret = Vec::new();
                for i in 0..len {
                    for j in 0..8 {
                        let b = (bytes[i] >> (7 - j)) & 1;
                        ret.push(b == 1);
                    }
                }
                ret
            }
            pub fn u32_to_bits_target<
                F: RichField + Extendable<D>,
                const D: usize,
                const B: usize,
            >(builder: &mut CircuitBuilder<F, D>, a: &U32Target) -> Vec<BoolTarget> {
                let mut res = Vec::new();
                let bit_targets = builder.split_le_base::<B>(a.0, 32);
                for i in (0..32).rev() {
                    res.push(BoolTarget::new_unsafe(bit_targets[i]));
                }
                res
            }
            pub fn bits_to_u32_target<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                bits_target: Vec<BoolTarget>,
            ) -> U32Target {
                let bit_len = bits_target.len();
                match (&bit_len, &32) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                U32Target(builder.le_sum(bits_target[0..32].iter().rev()))
            }
            fn rotate32(y: usize) -> Vec<usize> {
                let mut res = Vec::new();
                for i in 32 - y..32 {
                    res.push(i);
                }
                for i in 0..32 - y {
                    res.push(i);
                }
                res
            }
            fn shift32(y: usize) -> Vec<usize> {
                let mut res = Vec::new();
                for _ in 32 - y..32 {
                    res.push(32);
                }
                for i in 0..32 - y {
                    res.push(i);
                }
                res
            }
            fn xor3<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: BoolTarget,
                b: BoolTarget,
                c: BoolTarget,
            ) -> BoolTarget {
                let m = builder.mul(b.target, c.target);
                let two_b = builder.add(b.target, b.target);
                let two_c = builder.add(c.target, c.target);
                let two_m = builder.add(m, m);
                let four_m = builder.add(two_m, two_m);
                let one = builder.one();
                let one_sub_two_b = builder.sub(one, two_b);
                let one_sub_two_b_sub_two_c = builder.sub(one_sub_two_b, two_c);
                let one_sub_two_b_sub_two_c_add_four_m = builder
                    .add(one_sub_two_b_sub_two_c, four_m);
                let mut res = builder.mul(a.target, one_sub_two_b_sub_two_c_add_four_m);
                res = builder.add(res, b.target);
                res = builder.add(res, c.target);
                BoolTarget::new_unsafe(builder.sub(res, two_m))
            }
            fn big_sigma0<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
            ) -> U32Target {
                let a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                let rotate2 = rotate32(2);
                let rotate13 = rotate32(13);
                let rotate22 = rotate32(22);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    res_bits
                        .push(
                            xor3(
                                builder,
                                a_bits[rotate2[i]],
                                a_bits[rotate13[i]],
                                a_bits[rotate22[i]],
                            ),
                        );
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn big_sigma1<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
            ) -> U32Target {
                let a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                let rotate6 = rotate32(6);
                let rotate11 = rotate32(11);
                let rotate25 = rotate32(25);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    res_bits
                        .push(
                            xor3(
                                builder,
                                a_bits[rotate6[i]],
                                a_bits[rotate11[i]],
                                a_bits[rotate25[i]],
                            ),
                        );
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn sigma0<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
            ) -> U32Target {
                let mut a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                a_bits.push(builder.constant_bool(false));
                let rotate7 = rotate32(7);
                let rotate18 = rotate32(18);
                let shift3 = shift32(3);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    res_bits
                        .push(
                            xor3(
                                builder,
                                a_bits[rotate7[i]],
                                a_bits[rotate18[i]],
                                a_bits[shift3[i]],
                            ),
                        );
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn sigma1<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
            ) -> U32Target {
                let mut a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                a_bits.push(builder.constant_bool(false));
                let rotate17 = rotate32(17);
                let rotate19 = rotate32(19);
                let shift10 = shift32(10);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    res_bits
                        .push(
                            xor3(
                                builder,
                                a_bits[rotate17[i]],
                                a_bits[rotate19[i]],
                                a_bits[shift10[i]],
                            ),
                        );
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn ch<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
                b: &U32Target,
                c: &U32Target,
            ) -> U32Target {
                let a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                let b_bits = u32_to_bits_target::<F, D, 2>(builder, b);
                let c_bits = u32_to_bits_target::<F, D, 2>(builder, c);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    let b_sub_c = builder.sub(b_bits[i].target, c_bits[i].target);
                    let a_mul_b_sub_c = builder.mul(a_bits[i].target, b_sub_c);
                    let a_mul_b_sub_c_add_c = builder
                        .add(a_mul_b_sub_c, c_bits[i].target);
                    res_bits.push(BoolTarget::new_unsafe(a_mul_b_sub_c_add_c));
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn maj<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
                b: &U32Target,
                c: &U32Target,
            ) -> U32Target {
                let a_bits = u32_to_bits_target::<F, D, 2>(builder, a);
                let b_bits = u32_to_bits_target::<F, D, 2>(builder, b);
                let c_bits = u32_to_bits_target::<F, D, 2>(builder, c);
                let mut res_bits = Vec::new();
                for i in 0..32 {
                    let m = builder.mul(b_bits[i].target, c_bits[i].target);
                    let two = builder.two();
                    let two_m = builder.mul(two, m);
                    let b_add_c = builder.add(b_bits[i].target, c_bits[i].target);
                    let b_add_c_sub_two_m = builder.sub(b_add_c, two_m);
                    let a_mul_b_add_c_sub_two_m = builder
                        .mul(a_bits[i].target, b_add_c_sub_two_m);
                    let res = builder.add(a_mul_b_add_c_sub_two_m, m);
                    res_bits.push(BoolTarget::new_unsafe(res));
                }
                bits_to_u32_target(builder, res_bits)
            }
            fn add_u32<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                a: &U32Target,
                b: &U32Target,
            ) -> U32Target {
                let (res, _carry) = builder.add_u32(*a, *b);
                res
            }
            pub fn connect_arrays<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                first: &[Target],
                second: &[Target],
            ) {
                if !(first.len() == second.len()) {
                    ::core::panicking::panic(
                        "assertion failed: first.len() == second.len()",
                    )
                }
                for idx in 0..first.len() {
                    builder.connect(first[idx], second[idx]);
                }
            }
            pub fn connect_bool_arrays<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                first: &[BoolTarget],
                second: &[BoolTarget],
            ) {
                let first = first
                    .iter()
                    .map(|bool_target| bool_target.target)
                    .collect_vec();
                let second = second
                    .iter()
                    .map(|bool_target| bool_target.target)
                    .collect_vec();
                connect_arrays(builder, first.as_slice(), second.as_slice())
            }
            pub fn bool_arrays_are_equal<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                first: &[BoolTarget],
                second: &[BoolTarget],
            ) -> BoolTarget {
                let first = first
                    .iter()
                    .map(|bool_target| bool_target.target)
                    .collect_vec();
                let second = second
                    .iter()
                    .map(|bool_target| bool_target.target)
                    .collect_vec();
                arrays_are_equal(builder, first.as_slice(), second.as_slice())
            }
            pub fn arrays_are_equal<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                first: &[Target],
                second: &[Target],
            ) -> BoolTarget {
                if !(first.len() == second.len()) {
                    ::core::panicking::panic(
                        "assertion failed: first.len() == second.len()",
                    )
                }
                let mut result = builder._true();
                for idx in 0..first.len() {
                    let is_equal = builder.is_equal(first[idx], second[idx]);
                    result = builder.and(result, is_equal);
                }
                result
            }
            pub fn sha256_pair<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                left: &[BoolTarget],
                right: &[BoolTarget],
            ) -> Sha256 {
                let message = [left, right].concat();
                sha256(builder, message.as_slice())
            }
            pub fn sha256<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                message: &[BoolTarget],
            ) -> Sha256 {
                let mut digest = Vec::new();
                let block_count = (message.len() + 65 + 511) / 512;
                let padded_msg_len = 512 * block_count;
                let p = padded_msg_len - 64 - message.len();
                if !(p > 1) {
                    ::core::panicking::panic("assertion failed: p > 1")
                }
                let mut msg = message.to_owned();
                msg.push(builder.constant_bool(true));
                for _ in 0..p - 1 {
                    msg.push(builder.constant_bool(false));
                }
                for i in 0..64 {
                    let b = ((message.len() as u64) >> (63 - i)) & 1;
                    msg.push(builder.constant_bool(b == 1));
                }
                let mut state = Vec::new();
                for i in 0..8 {
                    state.push(builder.constant_u32(H256[i]));
                }
                let mut k256 = Vec::new();
                for i in 0..64 {
                    k256.push(builder.constant_u32(K256[i]));
                }
                for blk in 0..block_count {
                    let mut x = Vec::new();
                    let mut a = state[0].clone();
                    let mut b = state[1].clone();
                    let mut c = state[2].clone();
                    let mut d = state[3].clone();
                    let mut e = state[4].clone();
                    let mut f = state[5].clone();
                    let mut g = state[6].clone();
                    let mut h = state[7].clone();
                    for i in 0..16 {
                        let index = blk as usize * 512 + i * 32;
                        let u32_target = builder
                            .le_sum(msg[index..index + 32].iter().rev());
                        x.push(U32Target(u32_target));
                        let mut t1 = h.clone();
                        let big_sigma1_e = big_sigma1(builder, &e);
                        t1 = add_u32(builder, &t1, &big_sigma1_e);
                        let ch_e_f_g = ch(builder, &e, &f, &g);
                        t1 = add_u32(builder, &t1, &ch_e_f_g);
                        t1 = add_u32(builder, &t1, &k256[i]);
                        t1 = add_u32(builder, &t1, &x[i]);
                        let mut t2 = big_sigma0(builder, &a);
                        let maj_a_b_c = maj(builder, &a, &b, &c);
                        t2 = add_u32(builder, &t2, &maj_a_b_c);
                        h = g;
                        g = f;
                        f = e;
                        e = add_u32(builder, &d, &t1);
                        d = c;
                        c = b;
                        b = a;
                        a = add_u32(builder, &t1, &t2);
                    }
                    for i in 16..64 {
                        let s0 = sigma0(builder, &x[(i + 1) & 0x0f]);
                        let s1 = sigma1(builder, &x[(i + 14) & 0x0f]);
                        let s0_add_s1 = add_u32(builder, &s0, &s1);
                        let s0_add_s1_add_x = add_u32(
                            builder,
                            &s0_add_s1,
                            &x[(i + 9) & 0xf],
                        );
                        x[i & 0xf] = add_u32(builder, &x[i & 0xf], &s0_add_s1_add_x);
                        let big_sigma0_a = big_sigma0(builder, &a);
                        let big_sigma1_e = big_sigma1(builder, &e);
                        let ch_e_f_g = ch(builder, &e, &f, &g);
                        let maj_a_b_c = maj(builder, &a, &b, &c);
                        let h_add_sigma1 = add_u32(builder, &h, &big_sigma1_e);
                        let h_add_sigma1_add_ch_e_f_g = add_u32(
                            builder,
                            &h_add_sigma1,
                            &ch_e_f_g,
                        );
                        let h_add_sigma1_add_ch_e_f_g_add_k256 = add_u32(
                            builder,
                            &h_add_sigma1_add_ch_e_f_g,
                            &k256[i],
                        );
                        let t1 = add_u32(
                            builder,
                            &x[i & 0xf],
                            &h_add_sigma1_add_ch_e_f_g_add_k256,
                        );
                        let t2 = add_u32(builder, &big_sigma0_a, &maj_a_b_c);
                        h = g;
                        g = f;
                        f = e;
                        e = add_u32(builder, &d, &t1);
                        d = c;
                        c = b;
                        b = a;
                        a = add_u32(builder, &t1, &t2);
                    }
                    state[0] = add_u32(builder, &state[0], &a);
                    state[1] = add_u32(builder, &state[1], &b);
                    state[2] = add_u32(builder, &state[2], &c);
                    state[3] = add_u32(builder, &state[3], &d);
                    state[4] = add_u32(builder, &state[4], &e);
                    state[5] = add_u32(builder, &state[5], &f);
                    state[6] = add_u32(builder, &state[6], &g);
                    state[7] = add_u32(builder, &state[7], &h);
                }
                for i in 0..8 {
                    let bit_targets = builder.split_le_base::<2>(state[i].0, 32);
                    for j in (0..32).rev() {
                        digest.push(BoolTarget::new_unsafe(bit_targets[j]));
                    }
                }
                digest.try_into().unwrap()
            }
            pub fn make_circuits<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                msg_len_in_bits: u64,
            ) -> Sha256Targets {
                let mut message = Vec::new();
                let mut digest = Vec::new();
                let block_count = (msg_len_in_bits + 65 + 511) / 512;
                let padded_msg_len = 512 * block_count;
                let p = padded_msg_len - 64 - msg_len_in_bits;
                if !(p > 1) {
                    ::core::panicking::panic("assertion failed: p > 1")
                }
                for _ in 0..msg_len_in_bits {
                    message.push(builder.add_virtual_bool_target_unsafe());
                }
                message.push(builder.constant_bool(true));
                for _ in 0..p - 1 {
                    message.push(builder.constant_bool(false));
                }
                for i in 0..64 {
                    let b = ((msg_len_in_bits as u64) >> (63 - i)) & 1;
                    message.push(builder.constant_bool(b == 1));
                }
                let mut state = Vec::new();
                for i in 0..8 {
                    state.push(builder.constant_u32(H256[i]));
                }
                let mut k256 = Vec::new();
                for i in 0..64 {
                    k256.push(builder.constant_u32(K256[i]));
                }
                for blk in 0..block_count {
                    let mut x = Vec::new();
                    let mut a = state[0].clone();
                    let mut b = state[1].clone();
                    let mut c = state[2].clone();
                    let mut d = state[3].clone();
                    let mut e = state[4].clone();
                    let mut f = state[5].clone();
                    let mut g = state[6].clone();
                    let mut h = state[7].clone();
                    for i in 0..16 {
                        let index = blk as usize * 512 + i * 32;
                        let u32_target = builder
                            .le_sum(message[index..index + 32].iter().rev());
                        x.push(U32Target(u32_target));
                        let mut t1 = h.clone();
                        let big_sigma1_e = big_sigma1(builder, &e);
                        t1 = add_u32(builder, &t1, &big_sigma1_e);
                        let ch_e_f_g = ch(builder, &e, &f, &g);
                        t1 = add_u32(builder, &t1, &ch_e_f_g);
                        t1 = add_u32(builder, &t1, &k256[i]);
                        t1 = add_u32(builder, &t1, &x[i]);
                        let mut t2 = big_sigma0(builder, &a);
                        let maj_a_b_c = maj(builder, &a, &b, &c);
                        t2 = add_u32(builder, &t2, &maj_a_b_c);
                        h = g;
                        g = f;
                        f = e;
                        e = add_u32(builder, &d, &t1);
                        d = c;
                        c = b;
                        b = a;
                        a = add_u32(builder, &t1, &t2);
                    }
                    for i in 16..64 {
                        let s0 = sigma0(builder, &x[(i + 1) & 0x0f]);
                        let s1 = sigma1(builder, &x[(i + 14) & 0x0f]);
                        let s0_add_s1 = add_u32(builder, &s0, &s1);
                        let s0_add_s1_add_x = add_u32(
                            builder,
                            &s0_add_s1,
                            &x[(i + 9) & 0xf],
                        );
                        x[i & 0xf] = add_u32(builder, &x[i & 0xf], &s0_add_s1_add_x);
                        let big_sigma0_a = big_sigma0(builder, &a);
                        let big_sigma1_e = big_sigma1(builder, &e);
                        let ch_e_f_g = ch(builder, &e, &f, &g);
                        let maj_a_b_c = maj(builder, &a, &b, &c);
                        let h_add_sigma1 = add_u32(builder, &h, &big_sigma1_e);
                        let h_add_sigma1_add_ch_e_f_g = add_u32(
                            builder,
                            &h_add_sigma1,
                            &ch_e_f_g,
                        );
                        let h_add_sigma1_add_ch_e_f_g_add_k256 = add_u32(
                            builder,
                            &h_add_sigma1_add_ch_e_f_g,
                            &k256[i],
                        );
                        let t1 = add_u32(
                            builder,
                            &x[i & 0xf],
                            &h_add_sigma1_add_ch_e_f_g_add_k256,
                        );
                        let t2 = add_u32(builder, &big_sigma0_a, &maj_a_b_c);
                        h = g;
                        g = f;
                        f = e;
                        e = add_u32(builder, &d, &t1);
                        d = c;
                        c = b;
                        b = a;
                        a = add_u32(builder, &t1, &t2);
                    }
                    state[0] = add_u32(builder, &state[0], &a);
                    state[1] = add_u32(builder, &state[1], &b);
                    state[2] = add_u32(builder, &state[2], &c);
                    state[3] = add_u32(builder, &state[3], &d);
                    state[4] = add_u32(builder, &state[4], &e);
                    state[5] = add_u32(builder, &state[5], &f);
                    state[6] = add_u32(builder, &state[6], &g);
                    state[7] = add_u32(builder, &state[7], &h);
                }
                for i in 0..8 {
                    let bit_targets = builder.split_le_base::<2>(state[i].0, 32);
                    for j in (0..32).rev() {
                        digest.push(BoolTarget::new_unsafe(bit_targets[j]));
                    }
                }
                Sha256Targets { message, digest }
            }
        }
        pub mod validator_hash_tree_root {
            use plonky2::{
                field::extension::Extendable, hash::hash_types::RichField,
                iop::target::BoolTarget, plonk::circuit_builder::CircuitBuilder,
                util::serialization::{Buffer, IoResult, Read, Write},
            };
            use crate::{
                common_targets::{SSZLeafTarget, Sha256Target},
                serialization::targets_serialization::{ReadTargets, WriteTargets},
                utils::utils::{create_bool_target_array, ETH_SHA256_BIT_SIZE},
                validators_commitment_mapper::first_level::MerklelizedValidatorTarget,
            };
            use super::{
                hash_tree_root::{hash_tree_root, hash_tree_root_new},
                sha256::make_circuits,
            };
            pub struct ValidatorShaTargets {
                pub pubkey: [BoolTarget; 384],
                pub withdrawal_credentials: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub effective_balance: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub slashed: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub activation_eligibility_epoch: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub activation_epoch: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub exit_epoch: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub withdrawable_epoch: [BoolTarget; ETH_SHA256_BIT_SIZE],
            }
            impl ReadTargets for ValidatorShaTargets {
                fn read_targets(data: &mut Buffer) -> IoResult<ValidatorShaTargets> {
                    Ok(ValidatorShaTargets {
                        pubkey: data.read_target_bool_vec()?.try_into().unwrap(),
                        withdrawal_credentials: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                        effective_balance: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                        slashed: data.read_target_bool_vec()?.try_into().unwrap(),
                        activation_eligibility_epoch: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                        activation_epoch: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                        exit_epoch: data.read_target_bool_vec()?.try_into().unwrap(),
                        withdrawable_epoch: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                    })
                }
            }
            impl WriteTargets for ValidatorShaTargets {
                fn write_targets(&self) -> IoResult<Vec<u8>> {
                    let mut bytes = Vec::<u8>::new();
                    bytes.write_target_bool_vec(&self.pubkey)?;
                    bytes.write_target_bool_vec(&self.withdrawal_credentials)?;
                    bytes.write_target_bool_vec(&self.effective_balance)?;
                    bytes.write_target_bool_vec(&self.slashed)?;
                    bytes.write_target_bool_vec(&self.activation_eligibility_epoch)?;
                    bytes.write_target_bool_vec(&self.activation_epoch)?;
                    bytes.write_target_bool_vec(&self.exit_epoch)?;
                    bytes.write_target_bool_vec(&self.withdrawable_epoch)?;
                    Ok(bytes)
                }
            }
            pub struct ValidatorHashTreeRootTargets {
                pub validator: ValidatorShaTargets,
                pub hash_tree_root: [BoolTarget; ETH_SHA256_BIT_SIZE],
            }
            pub fn hash_tree_root_validator_sha256<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                validator: &MerklelizedValidatorTarget,
            ) -> Sha256Target {
                hash_tree_root_new(
                    builder,
                    &[
                        validator.pubkey[0],
                        validator.pubkey[1],
                        validator.withdrawal_credentials,
                        validator.effective_balance,
                        validator.slashed,
                        validator.activation_eligibility_epoch,
                        validator.activation_epoch,
                        validator.exit_epoch,
                        validator.withdrawable_epoch,
                    ],
                )
            }
            pub fn hash_tree_root_validator_sha256_or_zeroes<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                validator: &MerklelizedValidatorTarget,
                condition: BoolTarget,
            ) -> Sha256Target {
                let zero_leaf: SSZLeafTarget = [builder._false(); 256];
                let zero_leaves = [zero_leaf; 7];
                let mut leaves = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        validator.pubkey[0],
                        validator.pubkey[1],
                        validator.withdrawal_credentials,
                        validator.effective_balance,
                        validator.slashed,
                        validator.activation_eligibility_epoch,
                        validator.activation_epoch,
                        validator.exit_epoch,
                        validator.withdrawable_epoch,
                    ]),
                );
                leaves.extend(zero_leaves);
                let validator_hash = hash_tree_root_new(builder, &leaves);
                validator_hash.map(|bit| builder.and(condition, bit))
            }
        }
        pub mod validator_hash_tree_root_poseidon {
            use crate::serializers::serde_bool_array_to_hex_string;
            use circuit_derive::AddVirtualTarget;
            use circuit_derive::SerdeCircuitTarget;
            use circuit_derive::{PublicInputsReadable, SetWitness, TargetPrimitive};
            use plonky2::{
                field::extension::Extendable,
                hash::{
                    hash_types::{HashOutTarget, RichField},
                    poseidon::PoseidonHash,
                },
                iop::target::BoolTarget, plonk::circuit_builder::CircuitBuilder,
                util::serialization::{Buffer, IoResult, Read, Write},
            };
            use crate::{
                serialization::targets_serialization::{ReadTargets, WriteTargets},
                serializers::{biguint_to_str, parse_biguint},
                utils::{
                    biguint::{BigUintTarget, CircuitBuilderBiguint},
                    utils::{create_bool_target_array, ETH_SHA256_BIT_SIZE},
                },
            };
            use super::hash_tree_root_poseidon::hash_tree_root_poseidon;
            #[serde(rename_all = "camelCase")]
            pub struct ValidatorTarget {
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub pubkey: [BoolTarget; 384],
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub withdrawal_credentials: [BoolTarget; ETH_SHA256_BIT_SIZE],
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub effective_balance: BigUintTarget,
                pub slashed: BoolTarget,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_eligibility_epoch: BigUintTarget,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_epoch: BigUintTarget,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub exit_epoch: BigUintTarget,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub withdrawable_epoch: BigUintTarget,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ValidatorTarget {
                #[inline]
                fn clone(&self) -> ValidatorTarget {
                    ValidatorTarget {
                        pubkey: ::core::clone::Clone::clone(&self.pubkey),
                        withdrawal_credentials: ::core::clone::Clone::clone(
                            &self.withdrawal_credentials,
                        ),
                        effective_balance: ::core::clone::Clone::clone(
                            &self.effective_balance,
                        ),
                        slashed: ::core::clone::Clone::clone(&self.slashed),
                        activation_eligibility_epoch: ::core::clone::Clone::clone(
                            &self.activation_eligibility_epoch,
                        ),
                        activation_epoch: ::core::clone::Clone::clone(
                            &self.activation_epoch,
                        ),
                        exit_epoch: ::core::clone::Clone::clone(&self.exit_epoch),
                        withdrawable_epoch: ::core::clone::Clone::clone(
                            &self.withdrawable_epoch,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ValidatorTarget {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "pubkey",
                        "withdrawal_credentials",
                        "effective_balance",
                        "slashed",
                        "activation_eligibility_epoch",
                        "activation_epoch",
                        "exit_epoch",
                        "withdrawable_epoch",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.pubkey,
                        &self.withdrawal_credentials,
                        &self.effective_balance,
                        &self.slashed,
                        &self.activation_eligibility_epoch,
                        &self.activation_epoch,
                        &self.exit_epoch,
                        &&self.withdrawable_epoch,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ValidatorTarget",
                        names,
                        values,
                    )
                }
            }
            #[serde(rename_all = "camelCase")]
            pub struct ValidatorTargetPrimitive {
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub pubkey: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub withdrawal_credentials: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub effective_balance: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                pub slashed: <BoolTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_eligibility_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub exit_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub withdrawable_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ValidatorTargetPrimitive {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "pubkey",
                        "withdrawal_credentials",
                        "effective_balance",
                        "slashed",
                        "activation_eligibility_epoch",
                        "activation_epoch",
                        "exit_epoch",
                        "withdrawable_epoch",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.pubkey,
                        &self.withdrawal_credentials,
                        &self.effective_balance,
                        &self.slashed,
                        &self.activation_eligibility_epoch,
                        &self.activation_epoch,
                        &self.exit_epoch,
                        &&self.withdrawable_epoch,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ValidatorTargetPrimitive",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ValidatorTargetPrimitive {
                #[inline]
                fn clone(&self) -> ValidatorTargetPrimitive {
                    ValidatorTargetPrimitive {
                        pubkey: ::core::clone::Clone::clone(&self.pubkey),
                        withdrawal_credentials: ::core::clone::Clone::clone(
                            &self.withdrawal_credentials,
                        ),
                        effective_balance: ::core::clone::Clone::clone(
                            &self.effective_balance,
                        ),
                        slashed: ::core::clone::Clone::clone(&self.slashed),
                        activation_eligibility_epoch: ::core::clone::Clone::clone(
                            &self.activation_eligibility_epoch,
                        ),
                        activation_epoch: ::core::clone::Clone::clone(
                            &self.activation_epoch,
                        ),
                        exit_epoch: ::core::clone::Clone::clone(&self.exit_epoch),
                        withdrawable_epoch: ::core::clone::Clone::clone(
                            &self.withdrawable_epoch,
                        ),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ValidatorTargetPrimitive {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ValidatorTargetPrimitive",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "pubkey",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        serde_bool_array_to_hex_string::serialize(
                                            self.values.0,
                                            __s,
                                        )
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.pubkey,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "withdrawalCredentials",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        serde_bool_array_to_hex_string::serialize(
                                            self.values.0,
                                            __s,
                                        )
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.withdrawal_credentials,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "effectiveBalance",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.effective_balance,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "slashed",
                            &self.slashed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "activationEligibilityEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.activation_eligibility_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "activationEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.activation_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "exitEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.exit_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "withdrawableEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.withdrawable_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPrimitive,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ValidatorTargetPrimitive {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "pubkey" => _serde::__private::Ok(__Field::__field0),
                                    "withdrawalCredentials" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "effectiveBalance" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "slashed" => _serde::__private::Ok(__Field::__field3),
                                    "activationEligibilityEpoch" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "activationEpoch" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "exitEpoch" => _serde::__private::Ok(__Field::__field6),
                                    "withdrawableEpoch" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"pubkey" => _serde::__private::Ok(__Field::__field0),
                                    b"withdrawalCredentials" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"effectiveBalance" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"slashed" => _serde::__private::Ok(__Field::__field3),
                                    b"activationEligibilityEpoch" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"activationEpoch" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"exitEpoch" => _serde::__private::Ok(__Field::__field6),
                                    b"withdrawableEpoch" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ValidatorTargetPrimitive,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ValidatorTargetPrimitive;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ValidatorTargetPrimitive",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: serde_bool_array_to_hex_string::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: serde_bool_array_to_hex_string::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPrimitive,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct ValidatorTargetPrimitive with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ValidatorTargetPrimitive {
                                    pubkey: __field0,
                                    withdrawal_credentials: __field1,
                                    effective_balance: __field2,
                                    slashed: __field3,
                                    activation_eligibility_epoch: __field4,
                                    activation_epoch: __field5,
                                    exit_epoch: __field6,
                                    withdrawable_epoch: __field7,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: serde_bool_array_to_hex_string::deserialize(
                                                                __deserializer,
                                                            )?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "withdrawalCredentials",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: serde_bool_array_to_hex_string::deserialize(
                                                                __deserializer,
                                                            )?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "effectiveBalance",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "slashed",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "activationEligibilityEpoch",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "activationEpoch",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "exitEpoch",
                                                    ),
                                                );
                                            }
                                            __field6 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "withdrawableEpoch",
                                                    ),
                                                );
                                            }
                                            __field7 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPrimitive,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field("pubkey"),
                                        );
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "effectiveBalance",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("slashed")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "activationEligibilityEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "activationEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "exitEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "withdrawableEpoch",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ValidatorTargetPrimitive {
                                    pubkey: __field0,
                                    withdrawal_credentials: __field1,
                                    effective_balance: __field2,
                                    slashed: __field3,
                                    activation_eligibility_epoch: __field4,
                                    activation_epoch: __field5,
                                    exit_epoch: __field6,
                                    withdrawable_epoch: __field7,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "pubkey",
                            "withdrawalCredentials",
                            "effectiveBalance",
                            "slashed",
                            "activationEligibilityEpoch",
                            "activationEpoch",
                            "exitEpoch",
                            "withdrawableEpoch",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ValidatorTargetPrimitive",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ValidatorTargetPrimitive,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl circuit::TargetPrimitive for ValidatorTarget {
                type Primitive = ValidatorTargetPrimitive;
            }
            impl<F: RichField> circuit::SetWitness<F> for ValidatorTarget {
                type Input = <ValidatorTarget as circuit::TargetPrimitive>::Primitive;
                fn set_witness(
                    &self,
                    witness: &mut plonky2::iop::witness::PartialWitness<F>,
                    input: &Self::Input,
                ) {
                    <[BoolTarget; 384] as circuit::SetWitness<
                        F,
                    >>::set_witness(&self.pubkey, witness, &input.pubkey);
                    <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::SetWitness<
                        F,
                    >>::set_witness(
                        &self.withdrawal_credentials,
                        witness,
                        &input.withdrawal_credentials,
                    );
                    <BigUintTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(
                        &self.effective_balance,
                        witness,
                        &input.effective_balance,
                    );
                    <BoolTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(&self.slashed, witness, &input.slashed);
                    <BigUintTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(
                        &self.activation_eligibility_epoch,
                        witness,
                        &input.activation_eligibility_epoch,
                    );
                    <BigUintTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(
                        &self.activation_epoch,
                        witness,
                        &input.activation_epoch,
                    );
                    <BigUintTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(&self.exit_epoch, witness, &input.exit_epoch);
                    <BigUintTarget as circuit::SetWitness<
                        F,
                    >>::set_witness(
                        &self.withdrawable_epoch,
                        witness,
                        &input.withdrawable_epoch,
                    );
                }
            }
            pub struct ValidatorTargetPublicInputsTarget {
                pub pubkey: [BoolTarget; 384],
                pub withdrawal_credentials: [BoolTarget; ETH_SHA256_BIT_SIZE],
                pub effective_balance: BigUintTarget,
                pub slashed: BoolTarget,
                pub activation_eligibility_epoch: BigUintTarget,
                pub activation_epoch: BigUintTarget,
                pub exit_epoch: BigUintTarget,
                pub withdrawable_epoch: BigUintTarget,
            }
            impl circuit::PublicInputsTargetReadable for ValidatorTarget {
                fn get_size() -> usize {
                    let mut size = 0;
                    size
                        += <[BoolTarget; 384] as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BigUintTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BoolTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BigUintTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BigUintTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BigUintTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                        += <BigUintTarget as circuit::PublicInputsTargetReadable>::get_size();
                    size
                }
                fn from_targets(targets: &[plonky2::iop::target::Target]) -> Self {
                    match (
                        &targets.len(),
                        &<Self as circuit::PublicInputsTargetReadable>::get_size(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                    let mut reader = circuit::PublicInputsTargetReader::new(targets);
                    let pubkey = reader.read_object::<[BoolTarget; 384]>();
                    let withdrawal_credentials = reader
                        .read_object::<[BoolTarget; ETH_SHA256_BIT_SIZE]>();
                    let effective_balance = reader.read_object::<BigUintTarget>();
                    let slashed = reader.read_object::<BoolTarget>();
                    let activation_eligibility_epoch = reader
                        .read_object::<BigUintTarget>();
                    let activation_epoch = reader.read_object::<BigUintTarget>();
                    let exit_epoch = reader.read_object::<BigUintTarget>();
                    let withdrawable_epoch = reader.read_object::<BigUintTarget>();
                    ValidatorTarget {
                        pubkey,
                        withdrawal_credentials,
                        effective_balance,
                        slashed,
                        activation_eligibility_epoch,
                        activation_epoch,
                        exit_epoch,
                        withdrawable_epoch,
                    }
                }
            }
            #[serde(rename_all = "camelCase")]
            pub struct ValidatorTargetPublicInputs {
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub pubkey: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                #[serde(with = "serde_bool_array_to_hex_string")]
                pub withdrawal_credentials: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub effective_balance: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                pub slashed: <BoolTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_eligibility_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub activation_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub exit_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                #[serde(
                    serialize_with = "biguint_to_str",
                    deserialize_with = "parse_biguint"
                )]
                pub withdrawable_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ValidatorTargetPublicInputs {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "pubkey",
                        "withdrawal_credentials",
                        "effective_balance",
                        "slashed",
                        "activation_eligibility_epoch",
                        "activation_epoch",
                        "exit_epoch",
                        "withdrawable_epoch",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.pubkey,
                        &self.withdrawal_credentials,
                        &self.effective_balance,
                        &self.slashed,
                        &self.activation_eligibility_epoch,
                        &self.activation_epoch,
                        &self.exit_epoch,
                        &&self.withdrawable_epoch,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ValidatorTargetPublicInputs",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ValidatorTargetPublicInputs {
                #[inline]
                fn clone(&self) -> ValidatorTargetPublicInputs {
                    ValidatorTargetPublicInputs {
                        pubkey: ::core::clone::Clone::clone(&self.pubkey),
                        withdrawal_credentials: ::core::clone::Clone::clone(
                            &self.withdrawal_credentials,
                        ),
                        effective_balance: ::core::clone::Clone::clone(
                            &self.effective_balance,
                        ),
                        slashed: ::core::clone::Clone::clone(&self.slashed),
                        activation_eligibility_epoch: ::core::clone::Clone::clone(
                            &self.activation_eligibility_epoch,
                        ),
                        activation_epoch: ::core::clone::Clone::clone(
                            &self.activation_epoch,
                        ),
                        exit_epoch: ::core::clone::Clone::clone(&self.exit_epoch),
                        withdrawable_epoch: ::core::clone::Clone::clone(
                            &self.withdrawable_epoch,
                        ),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ValidatorTargetPublicInputs {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ValidatorTargetPublicInputs",
                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "pubkey",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        serde_bool_array_to_hex_string::serialize(
                                            self.values.0,
                                            __s,
                                        )
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.pubkey,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "withdrawalCredentials",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        serde_bool_array_to_hex_string::serialize(
                                            self.values.0,
                                            __s,
                                        )
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.withdrawal_credentials,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "effectiveBalance",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.effective_balance,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "slashed",
                            &self.slashed,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "activationEligibilityEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.activation_eligibility_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "activationEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.activation_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "exitEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.exit_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "withdrawableEpoch",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (
                                        &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    ),
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        biguint_to_str(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.withdrawable_epoch,),
                                    phantom: _serde::__private::PhantomData::<
                                        ValidatorTargetPublicInputs,
                                    >,
                                }
                            },
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ValidatorTargetPublicInputs {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "pubkey" => _serde::__private::Ok(__Field::__field0),
                                    "withdrawalCredentials" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "effectiveBalance" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "slashed" => _serde::__private::Ok(__Field::__field3),
                                    "activationEligibilityEpoch" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "activationEpoch" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "exitEpoch" => _serde::__private::Ok(__Field::__field6),
                                    "withdrawableEpoch" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"pubkey" => _serde::__private::Ok(__Field::__field0),
                                    b"withdrawalCredentials" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"effectiveBalance" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"slashed" => _serde::__private::Ok(__Field::__field3),
                                    b"activationEligibilityEpoch" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"activationEpoch" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"exitEpoch" => _serde::__private::Ok(__Field::__field6),
                                    b"withdrawableEpoch" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ValidatorTargetPublicInputs,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ValidatorTargetPublicInputs;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ValidatorTargetPublicInputs",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: serde_bool_array_to_hex_string::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: serde_bool_array_to_hex_string::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                6usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                        phantom: _serde::__private::PhantomData<
                                            ValidatorTargetPublicInputs,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: parse_biguint(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                7usize,
                                                &"struct ValidatorTargetPublicInputs with 8 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ValidatorTargetPublicInputs {
                                    pubkey: __field0,
                                    withdrawal_credentials: __field1,
                                    effective_balance: __field2,
                                    slashed: __field3,
                                    activation_eligibility_epoch: __field4,
                                    activation_epoch: __field5,
                                    exit_epoch: __field6,
                                    withdrawable_epoch: __field7,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field6: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                let mut __field7: _serde::__private::Option<
                                    <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("pubkey"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <[BoolTarget; 384] as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: serde_bool_array_to_hex_string::deserialize(
                                                                __deserializer,
                                                            )?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "withdrawalCredentials",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: serde_bool_array_to_hex_string::deserialize(
                                                                __deserializer,
                                                            )?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "effectiveBalance",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "slashed",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    <BoolTarget as circuit::TargetPrimitive>::Primitive,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "activationEligibilityEpoch",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "activationEpoch",
                                                    ),
                                                );
                                            }
                                            __field5 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field6 => {
                                            if _serde::__private::Option::is_some(&__field6) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "exitEpoch",
                                                    ),
                                                );
                                            }
                                            __field6 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field7 => {
                                            if _serde::__private::Option::is_some(&__field7) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "withdrawableEpoch",
                                                    ),
                                                );
                                            }
                                            __field7 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                    phantom: _serde::__private::PhantomData<
                                                        ValidatorTargetPublicInputs,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: parse_biguint(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field("pubkey"),
                                        );
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "withdrawalCredentials",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "effectiveBalance",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("slashed")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "activationEligibilityEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "activationEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field6 = match __field6 {
                                    _serde::__private::Some(__field6) => __field6,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "exitEpoch",
                                            ),
                                        );
                                    }
                                };
                                let __field7 = match __field7 {
                                    _serde::__private::Some(__field7) => __field7,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "withdrawableEpoch",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ValidatorTargetPublicInputs {
                                    pubkey: __field0,
                                    withdrawal_credentials: __field1,
                                    effective_balance: __field2,
                                    slashed: __field3,
                                    activation_eligibility_epoch: __field4,
                                    activation_epoch: __field5,
                                    exit_epoch: __field6,
                                    withdrawable_epoch: __field7,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "pubkey",
                            "withdrawalCredentials",
                            "effectiveBalance",
                            "slashed",
                            "activationEligibilityEpoch",
                            "activationEpoch",
                            "exitEpoch",
                            "withdrawableEpoch",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ValidatorTargetPublicInputs",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ValidatorTargetPublicInputs,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl circuit::PublicInputsReadable for ValidatorTarget {
                fn from_elements<F: plonky2::hash::hash_types::RichField>(
                    elements: &[F],
                ) -> Self::Primitive {
                    match (
                        &elements.len(),
                        &<Self as circuit::PublicInputsTargetReadable>::get_size(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                    let mut reader = circuit::PublicInputsFieldReader::new(elements);
                    let pubkey = reader.read_object::<[BoolTarget; 384]>();
                    let withdrawal_credentials = reader
                        .read_object::<[BoolTarget; ETH_SHA256_BIT_SIZE]>();
                    let effective_balance = reader.read_object::<BigUintTarget>();
                    let slashed = reader.read_object::<BoolTarget>();
                    let activation_eligibility_epoch = reader
                        .read_object::<BigUintTarget>();
                    let activation_epoch = reader.read_object::<BigUintTarget>();
                    let exit_epoch = reader.read_object::<BigUintTarget>();
                    let withdrawable_epoch = reader.read_object::<BigUintTarget>();
                    ValidatorTargetPrimitive {
                        pubkey,
                        withdrawal_credentials,
                        effective_balance,
                        slashed,
                        activation_eligibility_epoch,
                        activation_epoch,
                        exit_epoch,
                        withdrawable_epoch,
                    }
                }
            }
            impl circuit::ToTargets for ValidatorTarget {
                fn to_targets(&self) -> Vec<plonky2::iop::target::Target> {
                    let mut targets = Vec::new();
                    targets
                        .extend(
                            <[BoolTarget; 384] as circuit::ToTargets>::to_targets(
                                &self.pubkey,
                            ),
                        );
                    targets
                        .extend(
                            <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::ToTargets>::to_targets(
                                &self.withdrawal_credentials,
                            ),
                        );
                    targets
                        .extend(
                            <BigUintTarget as circuit::ToTargets>::to_targets(
                                &self.effective_balance,
                            ),
                        );
                    targets
                        .extend(
                            <BoolTarget as circuit::ToTargets>::to_targets(&self.slashed),
                        );
                    targets
                        .extend(
                            <BigUintTarget as circuit::ToTargets>::to_targets(
                                &self.activation_eligibility_epoch,
                            ),
                        );
                    targets
                        .extend(
                            <BigUintTarget as circuit::ToTargets>::to_targets(
                                &self.activation_epoch,
                            ),
                        );
                    targets
                        .extend(
                            <BigUintTarget as circuit::ToTargets>::to_targets(
                                &self.exit_epoch,
                            ),
                        );
                    targets
                        .extend(
                            <BigUintTarget as circuit::ToTargets>::to_targets(
                                &self.withdrawable_epoch,
                            ),
                        );
                    targets
                }
            }
            impl circuit::AddVirtualTarget for ValidatorTarget {
                fn add_virtual_target<
                    F: plonky2::hash::hash_types::RichField
                        + plonky2::field::extension::Extendable<D>,
                    const D: usize,
                >(
                    builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
                ) -> Self {
                    let pubkey = <[BoolTarget; 384] as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let withdrawal_credentials = <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let effective_balance = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let slashed = <BoolTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let activation_eligibility_epoch = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let activation_epoch = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let exit_epoch = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    let withdrawable_epoch = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                        builder,
                    );
                    ValidatorTarget {
                        pubkey,
                        withdrawal_credentials,
                        effective_balance,
                        slashed,
                        activation_eligibility_epoch,
                        activation_epoch,
                        exit_epoch,
                        withdrawable_epoch,
                    }
                }
            }
            impl circuit::SerdeCircuitTarget for ValidatorTarget {
                fn serialize(&self) -> plonky2::util::serialization::IoResult<Vec<u8>> {
                    let mut buffer: Vec<u8> = Vec::new();
                    buffer
                        .extend(
                            <[BoolTarget; 384] as circuit::SerdeCircuitTarget>::serialize(
                                &self.pubkey,
                            )?,
                        );
                    buffer
                        .extend(
                            <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::SerdeCircuitTarget>::serialize(
                                &self.withdrawal_credentials,
                            )?,
                        );
                    buffer
                        .extend(
                            <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.effective_balance,
                            )?,
                        );
                    buffer
                        .extend(
                            <BoolTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.slashed,
                            )?,
                        );
                    buffer
                        .extend(
                            <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.activation_eligibility_epoch,
                            )?,
                        );
                    buffer
                        .extend(
                            <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.activation_epoch,
                            )?,
                        );
                    buffer
                        .extend(
                            <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.exit_epoch,
                            )?,
                        );
                    buffer
                        .extend(
                            <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                                &self.withdrawable_epoch,
                            )?,
                        );
                    Ok(buffer)
                }
                fn deserialize(
                    buffer: &mut plonky2::util::serialization::Buffer,
                ) -> plonky2::util::serialization::IoResult<Self>
                where
                    Self: Sized,
                {
                    Ok(Self {
                        pubkey: <[BoolTarget; 384] as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        withdrawal_credentials: <[BoolTarget; ETH_SHA256_BIT_SIZE] as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        effective_balance: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        slashed: <BoolTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        activation_eligibility_epoch: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        activation_epoch: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        exit_epoch: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                        withdrawable_epoch: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                            buffer,
                        )?,
                    })
                }
            }
            impl ReadTargets for ValidatorTarget {
                fn read_targets(data: &mut Buffer) -> IoResult<ValidatorTarget> {
                    Ok(ValidatorTarget {
                        pubkey: data.read_target_bool_vec()?.try_into().unwrap(),
                        withdrawal_credentials: data
                            .read_target_bool_vec()?
                            .try_into()
                            .unwrap(),
                        effective_balance: BigUintTarget::read_targets(data)?,
                        slashed: data.read_target_bool()?,
                        activation_eligibility_epoch: BigUintTarget::read_targets(data)?,
                        activation_epoch: BigUintTarget::read_targets(data)?,
                        exit_epoch: BigUintTarget::read_targets(data)?,
                        withdrawable_epoch: BigUintTarget::read_targets(data)?,
                    })
                }
            }
            impl WriteTargets for ValidatorTarget {
                fn write_targets(&self) -> IoResult<Vec<u8>> {
                    let mut data = Vec::<u8>::new();
                    data.write_target_bool_vec(&self.pubkey)?;
                    data.write_target_bool_vec(&self.withdrawal_credentials)?;
                    data.extend(BigUintTarget::write_targets(&self.effective_balance)?);
                    data.write_target_bool(self.slashed)?;
                    data.extend(
                        BigUintTarget::write_targets(&self.activation_eligibility_epoch)?,
                    );
                    data.extend(BigUintTarget::write_targets(&self.activation_epoch)?);
                    data.extend(BigUintTarget::write_targets(&self.exit_epoch)?);
                    data.extend(BigUintTarget::write_targets(&self.withdrawable_epoch)?);
                    Ok(data)
                }
            }
            impl ValidatorTarget {
                pub fn new<F: RichField + Extendable<D>, const D: usize>(
                    builder: &mut CircuitBuilder<F, D>,
                ) -> ValidatorTarget {
                    let pubkey: [BoolTarget; 384] = (0..384)
                        .map(|_| builder.add_virtual_bool_target_safe())
                        .collect::<Vec<_>>()
                        .try_into()
                        .unwrap();
                    ValidatorTarget {
                        pubkey,
                        withdrawal_credentials: create_bool_target_array(builder),
                        effective_balance: builder.add_virtual_biguint_target(2),
                        slashed: builder.add_virtual_bool_target_safe(),
                        activation_eligibility_epoch: builder
                            .add_virtual_biguint_target(2),
                        activation_epoch: builder.add_virtual_biguint_target(2),
                        exit_epoch: builder.add_virtual_biguint_target(2),
                        withdrawable_epoch: builder.add_virtual_biguint_target(2),
                    }
                }
            }
            pub struct ValidatorPoseidonHashTreeRootTargets {
                pub validator: ValidatorTarget,
                pub hash_tree_root: HashOutTarget,
            }
            pub fn hash_tree_root_validator_poseidon_new<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
            ) -> ValidatorPoseidonHashTreeRootTargets {
                let validator = ValidatorTarget::new(builder);
                let leaves = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.pubkey.iter().map(|x| x.target).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawal_credentials
                                    .iter()
                                    .map(|x| x.target)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .effective_balance
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([validator.slashed.target]),
                                ),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_eligibility_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.exit_epoch.limbs.iter().map(|x| x.0).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawable_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                    ]),
                );
                let hash_tree_root_poseidon = hash_tree_root_poseidon(
                    builder,
                    leaves.len(),
                );
                for i in 0..leaves.len() {
                    builder.connect_hashes(leaves[i], hash_tree_root_poseidon.leaves[i]);
                }
                ValidatorPoseidonHashTreeRootTargets {
                    validator,
                    hash_tree_root: hash_tree_root_poseidon.hash_tree_root,
                }
            }
            pub fn hash_validator_poseidon_or_zeroes<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
                validator: &ValidatorTarget,
                condition: BoolTarget,
            ) -> HashOutTarget {
                let validator_hash = hash_validator_poseidon(builder, validator);
                HashOutTarget {
                    elements: validator_hash
                        .elements
                        .map(|element| builder.mul(condition.target, element)),
                }
            }
            pub fn hash_validator_poseidon<F: RichField + Extendable<D>, const D: usize>(
                builder: &mut CircuitBuilder<F, D>,
                validator: &ValidatorTarget,
            ) -> HashOutTarget {
                let leaves = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.pubkey.iter().map(|x| x.target).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawal_credentials
                                    .iter()
                                    .map(|x| x.target)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .effective_balance
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([validator.slashed.target]),
                                ),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_eligibility_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.exit_epoch.limbs.iter().map(|x| x.0).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawable_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                    ]),
                );
                let hash_tree_root_poseidon = hash_tree_root_poseidon(
                    builder,
                    leaves.len(),
                );
                for i in 0..leaves.len() {
                    builder.connect_hashes(leaves[i], hash_tree_root_poseidon.leaves[i]);
                }
                hash_tree_root_poseidon.hash_tree_root
            }
            pub fn hash_tree_root_validator_poseidon<
                F: RichField + Extendable<D>,
                const D: usize,
            >(
                builder: &mut CircuitBuilder<F, D>,
            ) -> ValidatorPoseidonHashTreeRootTargets {
                let validator = ValidatorTarget::new(builder);
                let leaves = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.pubkey.iter().map(|x| x.target).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawal_credentials
                                    .iter()
                                    .map(|x| x.target)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .effective_balance
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([validator.slashed.target]),
                                ),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_eligibility_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .activation_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(validator.exit_epoch.limbs.iter().map(|x| x.0).collect()),
                        builder
                            .hash_n_to_hash_no_pad::<
                                PoseidonHash,
                            >(
                                validator
                                    .withdrawable_epoch
                                    .limbs
                                    .iter()
                                    .map(|x| x.0)
                                    .collect(),
                            ),
                    ]),
                );
                let hash_tree_root_poseidon = hash_tree_root_poseidon(
                    builder,
                    leaves.len(),
                );
                for i in 0..leaves.len() {
                    builder.connect_hashes(leaves[i], hash_tree_root_poseidon.leaves[i]);
                }
                ValidatorPoseidonHashTreeRootTargets {
                    validator,
                    hash_tree_root: hash_tree_root_poseidon.hash_tree_root,
                }
            }
        }
    }
    pub mod is_active_validator {
        use plonky2::{
            field::extension::Extendable, hash::hash_types::RichField,
            iop::target::{BoolTarget, Target},
            plonk::circuit_builder::CircuitBuilder,
        };
        use crate::utils::{
            biguint::{BigUintTarget, CircuitBuilderBiguint},
            utils::biguint_is_equal,
        };
        pub struct IsActiveValidatorTargets {
            pub activation_epoch: [Target; 2],
            pub current_epoch: [Target; 2],
            pub exit_epoch: [Target; 2],
        }
        pub fn get_validator_status<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            activation_epoch: &BigUintTarget,
            current_epoch: &BigUintTarget,
            exit_epoch: &BigUintTarget,
        ) -> (BoolTarget, BoolTarget, BoolTarget) {
            let activation_epoch_le_current_epoch = builder
                .cmp_biguint(&activation_epoch, &current_epoch);
            let current_epoch_le_exit_epoch = builder
                .cmp_biguint(&current_epoch, &exit_epoch);
            let is_equal = biguint_is_equal(builder, current_epoch, exit_epoch);
            let not_equal = builder.not(is_equal);
            let current_epoch_lt_exit_epoch = builder
                .and(current_epoch_le_exit_epoch, not_equal);
            let is_not_activated = builder.not(activation_epoch_le_current_epoch);
            let is_valid_validator = builder
                .and(activation_epoch_le_current_epoch, current_epoch_lt_exit_epoch);
            let is_validator_exited = builder.not(current_epoch_lt_exit_epoch);
            (is_not_activated, is_valid_validator, is_validator_exited)
        }
    }
    pub mod utils {
        use itertools::Itertools;
        use num::BigUint;
        use plonky2::{
            field::{extension::Extendable, types::Field},
            hash::hash_types::RichField,
            iop::{
                target::{BoolTarget, Target},
                witness::{PartialWitness, WitnessWrite},
            },
            plonk::circuit_builder::CircuitBuilder,
        };
        use plonky2_u32::gadgets::arithmetic_u32::U32Target;
        use sha2::{Digest, Sha256};
        use crate::common_targets::SSZLeafTarget;
        use super::{
            biguint::{BigUintTarget, CircuitBuilderBiguint},
            hashing::is_valid_merkle_branch::MerkleBranch,
        };
        pub const ETH_SHA256_BIT_SIZE: usize = 256;
        pub const POSEIDON_HASH_SIZE: usize = 4;
        pub fn hex_string_from_field_element_bits<F: RichField>(bits: &[F]) -> String {
            if !(bits.len() % 4 == 0) {
                ::core::panicking::panic("assertion failed: bits.len() % 4 == 0")
            }
            let bits = bits
                .iter()
                .map(|element| element.to_canonical_u64() != 0)
                .collect_vec();
            hex::encode(bits_to_bytes(&bits))
        }
        pub fn biguint_target_from_limbs(limbs: &[Target]) -> BigUintTarget {
            BigUintTarget {
                limbs: limbs.iter().cloned().map(|x| U32Target(x)).collect_vec(),
            }
        }
        pub fn biguint_from_field_elements<F: RichField>(limbs: &[F]) -> BigUint {
            BigUint::from_slice(
                limbs
                    .iter()
                    .map(|element| element.to_canonical_u64() as u32)
                    .collect_vec()
                    .as_slice(),
            )
        }
        pub fn hash_bytes(bytes: &[u8]) -> Vec<u8> {
            let mut hasher = Sha256::new();
            hasher.update(bytes);
            hasher.finalize().to_vec()
        }
        pub fn target_to_le_bits<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            number: Target,
        ) -> [BoolTarget; 64] {
            builder
                .split_le(number, 64)
                .into_iter()
                .rev()
                .collect_vec()
                .try_into()
                .unwrap()
        }
        pub fn biguint_is_equal<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            a: &BigUintTarget,
            b: &BigUintTarget,
        ) -> BoolTarget {
            if !(a.limbs.len() == b.limbs.len()) {
                ::core::panicking::panic(
                    "assertion failed: a.limbs.len() == b.limbs.len()",
                )
            }
            let mut all_equal = builder._true();
            for i in 0..a.limbs.len() {
                let equal = builder.is_equal(a.limbs[i].0, b.limbs[i].0);
                all_equal = builder.and(all_equal, equal);
            }
            all_equal
        }
        pub fn bool_target_equal<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            a: &[BoolTarget; ETH_SHA256_BIT_SIZE],
            b: &[BoolTarget; ETH_SHA256_BIT_SIZE],
        ) -> BoolTarget {
            let mut all_equal = builder._true();
            for i in 0..ETH_SHA256_BIT_SIZE {
                let equal = builder.is_equal(a[i].target, b[i].target);
                all_equal = builder.and(all_equal, equal);
            }
            all_equal
        }
        pub fn create_sha256_merkle_proof<
            const DEPTH: usize,
            F: RichField + Extendable<D>,
            const D: usize,
        >(builder: &mut CircuitBuilder<F, D>) -> MerkleBranch<DEPTH> {
            [(); DEPTH].map(|_| create_bool_target_array(builder))
        }
        pub fn create_bool_target_array<
            F: RichField + Extendable<D>,
            const D: usize,
            const TARGETS_COUNT: usize,
        >(builder: &mut CircuitBuilder<F, D>) -> [BoolTarget; TARGETS_COUNT] {
            (0..TARGETS_COUNT)
                .map(|_| builder.add_virtual_bool_target_safe())
                .collect::<Vec<_>>()
                .try_into()
                .unwrap()
        }
        pub fn bits_to_biguint_target<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            bits_target: Vec<BoolTarget>,
        ) -> BigUintTarget {
            let bit_len = bits_target.len();
            match (&(bit_len % 32), &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            };
            let mut u32_targets = Vec::new();
            for i in 0..bit_len / 32 {
                u32_targets
                    .push(
                        U32Target(
                            builder
                                .le_sum(bits_target[i * 32..(i + 1) * 32].iter().rev()),
                        ),
                    );
            }
            u32_targets.reverse();
            BigUintTarget {
                limbs: u32_targets,
            }
        }
        pub fn biguint_to_bits_target<
            F: RichField + Extendable<D>,
            const D: usize,
            const B: usize,
        >(builder: &mut CircuitBuilder<F, D>, a: &BigUintTarget) -> Vec<BoolTarget> {
            let mut res = Vec::new();
            for i in (0..a.num_limbs()).rev() {
                let bit_targets = builder.split_le_base::<B>(a.get_limb(i).0, 32);
                for j in (0..32).rev() {
                    res.push(BoolTarget::new_unsafe(bit_targets[j]));
                }
            }
            res
        }
        pub fn biguint_to_le_bits_target<
            F: RichField + Extendable<D>,
            const D: usize,
            const B: usize,
        >(builder: &mut CircuitBuilder<F, D>, a: &BigUintTarget) -> Vec<BoolTarget> {
            biguint_to_bits_target::<F, D, B>(builder, a).into_iter().rev().collect_vec()
        }
        pub fn _right_rotate<const S: usize>(
            n: [BoolTarget; S],
            bits: usize,
        ) -> [BoolTarget; S] {
            let mut res = [None; S];
            for i in 0..S {
                res[i] = Some(n[((S - bits) + i) % S]);
            }
            res.map(|x| x.unwrap())
        }
        pub fn _shr<F: RichField + Extendable<D>, const D: usize, const S: usize>(
            n: [BoolTarget; S],
            bits: i64,
            builder: &mut CircuitBuilder<F, D>,
        ) -> [BoolTarget; S] {
            let mut res = [None; S];
            for i in 0..S {
                if (i as i64) < bits {
                    res[i] = Some(BoolTarget::new_unsafe(builder.constant(F::ZERO)));
                } else {
                    res[i] = Some(n[(i as i64 - bits) as usize]);
                }
            }
            res.map(|x| x.unwrap())
        }
        pub fn uint32_to_bits<F: RichField + Extendable<D>, const D: usize>(
            value: u32,
            builder: &mut CircuitBuilder<F, D>,
        ) -> [BoolTarget; 32] {
            let mut bits = [None; 32];
            for i in 0..32 {
                if value & (1 << (31 - i)) != 0 {
                    bits[i] = Some(BoolTarget::new_unsafe(builder.constant(F::ONE)));
                } else {
                    bits[i] = Some(BoolTarget::new_unsafe(builder.constant(F::ZERO)));
                }
            }
            bits.map(|x| x.unwrap())
        }
        fn reverse_endianness(bits: &[BoolTarget]) -> Vec<BoolTarget> {
            bits.chunks(8).rev().flatten().cloned().collect()
        }
        pub fn ssz_merklelize_bool<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            bool_target: BoolTarget,
        ) -> SSZLeafTarget {
            let mut ssz_leaf = [BoolTarget::new_unsafe(builder.zero()); 256];
            ssz_leaf[7] = bool_target;
            ssz_leaf
        }
        pub fn ssz_num_to_bits<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            num: &BigUintTarget,
            bit_len: usize,
        ) -> SSZLeafTarget {
            if !(bit_len <= ETH_SHA256_BIT_SIZE) {
                ::core::panicking::panic(
                    "assertion failed: bit_len <= ETH_SHA256_BIT_SIZE",
                )
            }
            let mut bits = reverse_endianness(
                &biguint_to_bits_target::<F, D, 2>(builder, num),
            );
            bits.extend((bit_len..ETH_SHA256_BIT_SIZE).map(|_| builder._false()));
            bits.try_into().unwrap()
        }
        pub fn ssz_num_from_bits<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            bits: &[BoolTarget],
        ) -> BigUintTarget {
            bits_to_biguint_target(builder, reverse_endianness(bits))
        }
        pub fn select_biguint<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            b: BoolTarget,
            x: &BigUintTarget,
            y: &BigUintTarget,
        ) -> BigUintTarget {
            let not_b = builder.not(b);
            let maybe_x = builder.mul_biguint_by_bool(x, b);
            let maybe_y = builder.mul_biguint_by_bool(y, not_b);
            let mut result = builder.add_biguint(&maybe_y, &maybe_x);
            result.limbs.pop();
            result
        }
        pub fn bytes_to_bits(bytes: &[u8]) -> Vec<bool> {
            let mut bits = Vec::new();
            for value in bytes {
                for i in (0..8).rev() {
                    let mask = 1 << i;
                    bits.push(value & mask != 0);
                }
            }
            bits
        }
        pub fn bits_to_bytes(bits: &[bool]) -> Vec<u8> {
            let mut bytes = Vec::new();
            let mut byte = 0u8;
            for (index, bit) in bits.iter().enumerate() {
                if *bit {
                    byte |= 1 << (7 - (index % 8));
                }
                if index % 8 == 7 {
                    bytes.push(byte);
                    byte = 0;
                }
            }
            if bits.len() % 8 != 0 {
                bytes.push(byte);
            }
            bytes
        }
        pub trait SetBytesArray<F: Field> {
            fn set_bytes_array(&mut self, targets: &[BoolTarget], values: &[u8]);
        }
        impl<F: Field> SetBytesArray<F> for PartialWitness<F> {
            fn set_bytes_array(&mut self, targets: &[BoolTarget], values: &[u8]) {
                if !(targets.len() == values.len() * 8) {
                    ::core::panicking::panic(
                        "assertion failed: targets.len() == values.len() * 8",
                    )
                }
                let bool_values = bytes_to_bits(values);
                for i in 0..targets.len() {
                    self.set_bool_target(targets[i], bool_values[i]);
                }
            }
        }
    }
}
pub mod validators_commitment_mapper {
    pub mod build_commitment_mapper_first_level_circuit {}
    pub mod build_commitment_mapper_inner_level_circuit {
        use circuit::{Circuit, CircuitOutputTarget};
        use plonky2::{
            field::goldilocks_field::GoldilocksField,
            plonk::{
                circuit_builder::CircuitBuilder,
                circuit_data::{CircuitConfig, CircuitData, VerifierCircuitTarget},
                config::PoseidonGoldilocksConfig,
            },
        };
        use crate::{
            common_targets::BasicRecursiveInnerCircuitTarget,
            utils::hashing::{poseidon::poseidon_pair, sha256::sha256_pair},
            validators_commitment_mapper::first_level::ValidatorsCommitmentMapperFirstLevel,
        };
        const D: usize = 2;
        pub struct ValidatorsCommitmentMapperInnerLevel {}
        impl Circuit for ValidatorsCommitmentMapperInnerLevel {
            type F = GoldilocksField;
            const D: usize = D;
            type C = PoseidonGoldilocksConfig;
            const CIRCUIT_CONFIG: CircuitConfig = CircuitConfig::standard_recursion_config();
            type Target = BasicRecursiveInnerCircuitTarget;
            type Params = CircuitData<Self::F, Self::C, D>;
            fn define(
                builder: &mut CircuitBuilder<Self::F, D>,
                circuit_data: &Self::Params,
            ) -> Self::Target {
                let verifier_circuit_target = VerifierCircuitTarget {
                    constants_sigmas_cap: builder
                        .constant_merkle_cap(
                            &circuit_data.verifier_only.constants_sigmas_cap,
                        ),
                    circuit_digest: builder
                        .constant_hash(circuit_data.verifier_only.circuit_digest),
                };
                let proof1 = builder.add_virtual_proof_with_pis(&circuit_data.common);
                let proof2 = builder.add_virtual_proof_with_pis(&circuit_data.common);
                builder
                    .verify_proof::<
                        Self::C,
                    >(&proof1, &verifier_circuit_target, &circuit_data.common);
                builder
                    .verify_proof::<
                        Self::C,
                    >(&proof2, &verifier_circuit_target, &circuit_data.common);
                let l_input = ValidatorsCommitmentMapperFirstLevel::read_public_inputs_target(
                    &proof1.public_inputs,
                );
                let r_input = ValidatorsCommitmentMapperFirstLevel::read_public_inputs_target(
                    &proof2.public_inputs,
                );
                let sha256_hash_tree_root = sha256_pair(
                    builder,
                    &l_input.sha256_hash_tree_root,
                    &r_input.sha256_hash_tree_root,
                );
                let poseidon_hash_tree_root = poseidon_pair(
                    builder,
                    l_input.poseidon_hash_tree_root,
                    r_input.poseidon_hash_tree_root,
                );
                let output_target = CircuitOutputTarget::<
                    ValidatorsCommitmentMapperFirstLevel,
                > {
                    sha256_hash_tree_root,
                    poseidon_hash_tree_root,
                };
                output_target.register_public_inputs(builder);
                Self::Target {
                    proof1,
                    proof2,
                    verifier_circuit_target,
                }
            }
        }
    }
    pub mod first_level {
        use circuit::Circuit;
        use circuit_derive::{CircuitTarget, SerdeCircuitTarget};
        use plonky2::{
            field::{extension::Extendable, goldilocks_field::GoldilocksField},
            hash::hash_types::{HashOutTarget, RichField},
            iop::target::BoolTarget,
            plonk::{
                circuit_builder::CircuitBuilder, circuit_data::CircuitConfig,
                config::PoseidonGoldilocksConfig,
            },
        };
        use crate::{
            common_targets::{SSZLeafTarget, Sha256Target},
            utils::{
                hashing::{
                    validator_hash_tree_root::hash_tree_root_validator_sha256_or_zeroes,
                    validator_hash_tree_root_poseidon::{
                        hash_validator_poseidon_or_zeroes, ValidatorTarget,
                    },
                },
                utils::{ssz_merklelize_bool, ssz_num_to_bits},
            },
        };
        pub struct MerklelizedValidatorTarget {
            pub pubkey: [SSZLeafTarget; 2],
            pub withdrawal_credentials: SSZLeafTarget,
            pub effective_balance: SSZLeafTarget,
            pub slashed: SSZLeafTarget,
            pub activation_eligibility_epoch: SSZLeafTarget,
            pub activation_epoch: SSZLeafTarget,
            pub exit_epoch: SSZLeafTarget,
            pub withdrawable_epoch: SSZLeafTarget,
        }
        pub fn merklelize_validator_target<F: RichField + Extendable<D>, const D: usize>(
            builder: &mut CircuitBuilder<F, D>,
            validator: &ValidatorTarget,
        ) -> MerklelizedValidatorTarget {
            let zero_bits_128 = [BoolTarget::new_unsafe(builder.zero()); 128];
            let first_pubkey_leaf: SSZLeafTarget = (&validator.pubkey[0..256])
                .try_into()
                .unwrap();
            let second_pubkey_leaf: SSZLeafTarget = [
                &validator.pubkey[256..],
                &zero_bits_128[..],
            ]
                .concat()
                .try_into()
                .unwrap();
            MerklelizedValidatorTarget {
                pubkey: [first_pubkey_leaf, second_pubkey_leaf],
                withdrawal_credentials: validator.withdrawal_credentials,
                effective_balance: ssz_num_to_bits(
                    builder,
                    &validator.effective_balance,
                    64,
                ),
                slashed: ssz_merklelize_bool(builder, validator.slashed),
                activation_eligibility_epoch: ssz_num_to_bits(
                    builder,
                    &validator.activation_eligibility_epoch,
                    64,
                ),
                activation_epoch: ssz_num_to_bits(
                    builder,
                    &validator.activation_epoch,
                    64,
                ),
                exit_epoch: ssz_num_to_bits(builder, &validator.exit_epoch, 64),
                withdrawable_epoch: ssz_num_to_bits(
                    builder,
                    &validator.withdrawable_epoch,
                    64,
                ),
            }
        }
        pub struct ValidatorsCommitmentMapperTarget {
            #[target(in)]
            pub validator: ValidatorTarget,
            pub validator_is_zero: BoolTarget,
            #[target(out)]
            pub sha256_hash_tree_root: Sha256Target,
            #[target(out)]
            pub poseidon_hash_tree_root: HashOutTarget,
        }
        pub struct ValidatorsCommitmentMapperTargetPublicInputs {
            pub sha256_hash_tree_root: <Sha256Target as circuit::TargetPrimitive>::Primitive,
            pub poseidon_hash_tree_root: <HashOutTarget as circuit::TargetPrimitive>::Primitive,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ValidatorsCommitmentMapperTargetPublicInputs {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ValidatorsCommitmentMapperTargetPublicInputs",
                    "sha256_hash_tree_root",
                    &self.sha256_hash_tree_root,
                    "poseidon_hash_tree_root",
                    &&self.poseidon_hash_tree_root,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ValidatorsCommitmentMapperTargetPublicInputs {
            #[inline]
            fn clone(&self) -> ValidatorsCommitmentMapperTargetPublicInputs {
                ValidatorsCommitmentMapperTargetPublicInputs {
                    sha256_hash_tree_root: ::core::clone::Clone::clone(
                        &self.sha256_hash_tree_root,
                    ),
                    poseidon_hash_tree_root: ::core::clone::Clone::clone(
                        &self.poseidon_hash_tree_root,
                    ),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ValidatorsCommitmentMapperTargetPublicInputs {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ValidatorsCommitmentMapperTargetPublicInputs",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sha256_hash_tree_root",
                        &self.sha256_hash_tree_root,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "poseidon_hash_tree_root",
                        &self.poseidon_hash_tree_root,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de>
            for ValidatorsCommitmentMapperTargetPublicInputs {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "sha256_hash_tree_root" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "poseidon_hash_tree_root" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"sha256_hash_tree_root" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"poseidon_hash_tree_root" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            ValidatorsCommitmentMapperTargetPublicInputs,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ValidatorsCommitmentMapperTargetPublicInputs;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ValidatorsCommitmentMapperTargetPublicInputs",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                <Sha256Target as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ValidatorsCommitmentMapperTargetPublicInputs with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ValidatorsCommitmentMapperTargetPublicInputs with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ValidatorsCommitmentMapperTargetPublicInputs {
                                sha256_hash_tree_root: __field0,
                                poseidon_hash_tree_root: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                <Sha256Target as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sha256_hash_tree_root",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <Sha256Target as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "poseidon_hash_tree_root",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "sha256_hash_tree_root",
                                    )?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "poseidon_hash_tree_root",
                                    )?
                                }
                            };
                            _serde::__private::Ok(ValidatorsCommitmentMapperTargetPublicInputs {
                                sha256_hash_tree_root: __field0,
                                poseidon_hash_tree_root: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "sha256_hash_tree_root",
                        "poseidon_hash_tree_root",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ValidatorsCommitmentMapperTargetPublicInputs",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ValidatorsCommitmentMapperTargetPublicInputs,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ValidatorsCommitmentMapperTargetPublicInputsTarget {
            pub sha256_hash_tree_root: Sha256Target,
            pub poseidon_hash_tree_root: HashOutTarget,
        }
        impl ValidatorsCommitmentMapperTargetPublicInputsTarget {
            pub fn register_public_inputs<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                &self,
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) {
                builder
                    .register_public_inputs(
                        &<Sha256Target as circuit::ToTargets>::to_targets(
                            &self.sha256_hash_tree_root,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<HashOutTarget as circuit::ToTargets>::to_targets(
                            &self.poseidon_hash_tree_root,
                        ),
                    );
            }
        }
        impl std::convert::From<ValidatorsCommitmentMapperTarget>
        for ValidatorsCommitmentMapperTargetPublicInputsTarget {
            fn from(
                value: ValidatorsCommitmentMapperTarget,
            ) -> ValidatorsCommitmentMapperTargetPublicInputsTarget {
                ValidatorsCommitmentMapperTargetPublicInputsTarget {
                    sha256_hash_tree_root: value.sha256_hash_tree_root,
                    poseidon_hash_tree_root: value.poseidon_hash_tree_root,
                }
            }
        }
        impl circuit::TargetsWithPublicInputs for ValidatorsCommitmentMapperTarget {
            type PublicInputs = ValidatorsCommitmentMapperTargetPublicInputs;
            #[allow(unused_variables)]
            fn read_public_inputs<F: plonky2::hash::hash_types::RichField>(
                public_inputs: &[F],
            ) -> Self::PublicInputs {
                let mut reader = circuit::PublicInputsFieldReader::new(public_inputs);
                let sha256_hash_tree_root = reader.read_object::<Sha256Target>();
                let poseidon_hash_tree_root = reader.read_object::<HashOutTarget>();
                ValidatorsCommitmentMapperTargetPublicInputs {
                    sha256_hash_tree_root,
                    poseidon_hash_tree_root,
                }
            }
            type PublicInputsTarget = ValidatorsCommitmentMapperTargetPublicInputsTarget;
            #[allow(unused_variables)]
            fn read_public_inputs_target(
                public_inputs: &[plonky2::iop::target::Target],
            ) -> Self::PublicInputsTarget {
                let mut reader = circuit::PublicInputsTargetReader::new(public_inputs);
                let sha256_hash_tree_root = reader.read_object::<Sha256Target>();
                let poseidon_hash_tree_root = reader.read_object::<HashOutTarget>();
                ValidatorsCommitmentMapperTargetPublicInputsTarget {
                    sha256_hash_tree_root,
                    poseidon_hash_tree_root,
                }
            }
            #[allow(unused_variables)]
            fn register_public_inputs<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                &self,
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) {
                builder
                    .register_public_inputs(
                        &<Sha256Target as circuit::ToTargets>::to_targets(
                            &self.sha256_hash_tree_root,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<HashOutTarget as circuit::ToTargets>::to_targets(
                            &self.poseidon_hash_tree_root,
                        ),
                    );
            }
        }
        pub struct ValidatorsCommitmentMapperTargetWitnessInput {
            pub validator: <ValidatorTarget as circuit::TargetPrimitive>::Primitive,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ValidatorsCommitmentMapperTargetWitnessInput {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ValidatorsCommitmentMapperTargetWitnessInput",
                    "validator",
                    &&self.validator,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ValidatorsCommitmentMapperTargetWitnessInput {
            #[inline]
            fn clone(&self) -> ValidatorsCommitmentMapperTargetWitnessInput {
                ValidatorsCommitmentMapperTargetWitnessInput {
                    validator: ::core::clone::Clone::clone(&self.validator),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ValidatorsCommitmentMapperTargetWitnessInput {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ValidatorsCommitmentMapperTargetWitnessInput",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "validator",
                        &self.validator,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de>
            for ValidatorsCommitmentMapperTargetWitnessInput {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "validator" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"validator" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            ValidatorsCommitmentMapperTargetWitnessInput,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ValidatorsCommitmentMapperTargetWitnessInput;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ValidatorsCommitmentMapperTargetWitnessInput",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                <ValidatorTarget as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ValidatorsCommitmentMapperTargetWitnessInput with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ValidatorsCommitmentMapperTargetWitnessInput {
                                validator: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                <ValidatorTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "validator",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <ValidatorTarget as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("validator")?
                                }
                            };
                            _serde::__private::Ok(ValidatorsCommitmentMapperTargetWitnessInput {
                                validator: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["validator"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ValidatorsCommitmentMapperTargetWitnessInput",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ValidatorsCommitmentMapperTargetWitnessInput,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl<F: plonky2::hash::hash_types::RichField> circuit::SetWitness<F>
        for ValidatorsCommitmentMapperTarget {
            type Input = ValidatorsCommitmentMapperTargetWitnessInput;
            #[allow(unused_variables)]
            fn set_witness(
                &self,
                witness: &mut plonky2::iop::witness::PartialWitness<F>,
                input: &Self::Input,
            ) {
                <ValidatorTarget as circuit::SetWitness<
                    F,
                >>::set_witness(&self.validator, witness, &input.validator);
            }
        }
        pub struct ValidatorsCommitmentMapperTargetCircuitInputTarget {
            pub validator: ValidatorTarget,
        }
        impl circuit::AddVirtualTarget
        for ValidatorsCommitmentMapperTargetCircuitInputTarget {
            fn add_virtual_target<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) -> Self {
                let validator = <ValidatorTarget as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                );
                ValidatorsCommitmentMapperTargetCircuitInputTarget {
                    validator,
                }
            }
        }
        impl circuit::ReadableCircuitInputTarget for ValidatorsCommitmentMapperTarget {
            type CircuitInputTarget = ValidatorsCommitmentMapperTargetCircuitInputTarget;
            fn read_circuit_input_target<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) -> Self::CircuitInputTarget {
                <Self::CircuitInputTarget as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                )
            }
        }
        impl circuit::SerdeCircuitTarget for ValidatorsCommitmentMapperTarget {
            fn serialize(&self) -> plonky2::util::serialization::IoResult<Vec<u8>> {
                let mut buffer: Vec<u8> = Vec::new();
                buffer
                    .extend(
                        <ValidatorTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.validator,
                        )?,
                    );
                buffer
                    .extend(
                        <BoolTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.validator_is_zero,
                        )?,
                    );
                buffer
                    .extend(
                        <Sha256Target as circuit::SerdeCircuitTarget>::serialize(
                            &self.sha256_hash_tree_root,
                        )?,
                    );
                buffer
                    .extend(
                        <HashOutTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.poseidon_hash_tree_root,
                        )?,
                    );
                Ok(buffer)
            }
            fn deserialize(
                buffer: &mut plonky2::util::serialization::Buffer,
            ) -> plonky2::util::serialization::IoResult<Self>
            where
                Self: Sized,
            {
                Ok(Self {
                    validator: <ValidatorTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    validator_is_zero: <BoolTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    sha256_hash_tree_root: <Sha256Target as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    poseidon_hash_tree_root: <HashOutTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                })
            }
        }
        pub struct ValidatorsCommitmentMapperFirstLevel {}
        impl Circuit for ValidatorsCommitmentMapperFirstLevel {
            type F = GoldilocksField;
            const D: usize = 2;
            type C = PoseidonGoldilocksConfig;
            const CIRCUIT_CONFIG: CircuitConfig = CircuitConfig::standard_recursion_config();
            type Target = ValidatorsCommitmentMapperTarget;
            type Params = ();
            fn define(
                builder: &mut CircuitBuilder<Self::F, { Self::D }>,
                _params: &Self::Params,
            ) -> Self::Target {
                let input = Self::read_circuit_input_target(builder);
                let validator_is_zero = builder.add_virtual_bool_target_safe();
                let merklelized_validator = merklelize_validator_target(
                    builder,
                    &input.validator,
                );
                let sha256_hash_tree_root = hash_tree_root_validator_sha256_or_zeroes(
                    builder,
                    &merklelized_validator,
                    validator_is_zero,
                );
                let poseidon_hash_tree_root = hash_validator_poseidon_or_zeroes(
                    builder,
                    &input.validator,
                    validator_is_zero,
                );
                Self::Target {
                    validator_is_zero,
                    validator: input.validator,
                    sha256_hash_tree_root,
                    poseidon_hash_tree_root,
                }
            }
        }
    }
}
pub mod withdrawal_credentials_balance_aggregator {
    pub mod first_level {
        use crate::serializers::serde_bool_array_to_hex_string;
        use crate::serializers::serde_bool_array_to_hex_string_nested;
        use crate::utils::hashing::hash_tree_root::hash_tree_root_new;
        use crate::utils::hashing::hash_tree_root_poseidon::hash_tree_root_poseidon_new;
        use crate::utils::hashing::validator_hash_tree_root_poseidon::hash_validator_poseidon_or_zeroes;
        use circuit::Circuit;
        use circuit_derive::CircuitTarget;
        use circuit_derive::SerdeCircuitTarget;
        use itertools::Itertools;
        use plonky2::{
            field::goldilocks_field::GoldilocksField, hash::hash_types::HashOutTarget,
            iop::target::{BoolTarget, Target},
            plonk::{
                circuit_builder::CircuitBuilder,
                circuit_data::{CircuitConfig, CircuitData},
                config::PoseidonGoldilocksConfig,
            },
        };
        use crate::{
            common_targets::Sha256Target, serializers::{biguint_to_str, parse_biguint},
            utils::{
                biguint::{BigUintTarget, CircuitBuilderBiguint},
                hashing::{
                    sha256::bool_arrays_are_equal,
                    validator_hash_tree_root_poseidon::ValidatorTarget,
                },
                is_active_validator::get_validator_status,
                utils::{select_biguint, ssz_num_from_bits},
            },
        };
        #[serde(rename_all = "camelCase")]
        pub struct ValidatorBalanceVerificationTargets<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[target(in)]
            pub validators: [ValidatorTarget; VALIDATORS_COUNT],
            #[target(in)]
            pub non_zero_validator_leaves_mask: [BoolTarget; VALIDATORS_COUNT],
            #[target(in)]
            #[serde(with = "serde_bool_array_to_hex_string_nested")]
            pub balances_leaves: [Sha256Target; VALIDATORS_COUNT / 4],
            #[target(in, out)]
            #[serde(with = "serde_bool_array_to_hex_string_nested")]
            pub withdrawal_credentials: [Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT],
            #[target(in, out)]
            #[serde(
                serialize_with = "biguint_to_str",
                deserialize_with = "parse_biguint"
            )]
            pub current_epoch: BigUintTarget,
            #[target(out)]
            #[serde(
                serialize_with = "biguint_to_str",
                deserialize_with = "parse_biguint"
            )]
            pub range_total_value: BigUintTarget,
            #[target(out)]
            #[serde(with = "serde_bool_array_to_hex_string")]
            pub range_balances_root: Sha256Target,
            #[target(out)]
            pub range_validator_commitment: HashOutTarget,
            #[target(out)]
            pub number_of_non_activated_validators: Target,
            #[target(out)]
            pub number_of_active_validators: Target,
            #[target(out)]
            pub number_of_exitted_validators: Target,
        }
        #[serde(rename_all = "camelCase")]
        pub struct ValidatorBalanceVerificationTargetsPublicInputs<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[serde(with = "serde_bool_array_to_hex_string_nested")]
            pub withdrawal_credentials: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
            #[serde(
                serialize_with = "biguint_to_str",
                deserialize_with = "parse_biguint"
            )]
            pub current_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
            #[serde(
                serialize_with = "biguint_to_str",
                deserialize_with = "parse_biguint"
            )]
            pub range_total_value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
            #[serde(with = "serde_bool_array_to_hex_string")]
            pub range_balances_root: <Sha256Target as circuit::TargetPrimitive>::Primitive,
            pub range_validator_commitment: <HashOutTarget as circuit::TargetPrimitive>::Primitive,
            pub number_of_non_activated_validators: <Target as circuit::TargetPrimitive>::Primitive,
            pub number_of_active_validators: <Target as circuit::TargetPrimitive>::Primitive,
            pub number_of_exitted_validators: <Target as circuit::TargetPrimitive>::Primitive,
        }
        #[automatically_derived]
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > ::core::fmt::Debug
        for ValidatorBalanceVerificationTargetsPublicInputs<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "withdrawal_credentials",
                    "current_epoch",
                    "range_total_value",
                    "range_balances_root",
                    "range_validator_commitment",
                    "number_of_non_activated_validators",
                    "number_of_active_validators",
                    "number_of_exitted_validators",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.withdrawal_credentials,
                    &self.current_epoch,
                    &self.range_total_value,
                    &self.range_balances_root,
                    &self.range_validator_commitment,
                    &self.number_of_non_activated_validators,
                    &self.number_of_active_validators,
                    &&self.number_of_exitted_validators,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ValidatorBalanceVerificationTargetsPublicInputs",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > ::core::clone::Clone
        for ValidatorBalanceVerificationTargetsPublicInputs<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[inline]
            fn clone(
                &self,
            ) -> ValidatorBalanceVerificationTargetsPublicInputs<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            > {
                ValidatorBalanceVerificationTargetsPublicInputs {
                    withdrawal_credentials: ::core::clone::Clone::clone(
                        &self.withdrawal_credentials,
                    ),
                    current_epoch: ::core::clone::Clone::clone(&self.current_epoch),
                    range_total_value: ::core::clone::Clone::clone(
                        &self.range_total_value,
                    ),
                    range_balances_root: ::core::clone::Clone::clone(
                        &self.range_balances_root,
                    ),
                    range_validator_commitment: ::core::clone::Clone::clone(
                        &self.range_validator_commitment,
                    ),
                    number_of_non_activated_validators: ::core::clone::Clone::clone(
                        &self.number_of_non_activated_validators,
                    ),
                    number_of_active_validators: ::core::clone::Clone::clone(
                        &self.number_of_active_validators,
                    ),
                    number_of_exitted_validators: ::core::clone::Clone::clone(
                        &self.number_of_exitted_validators,
                    ),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<
                const VALIDATORS_COUNT: usize,
                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
            > _serde::Serialize
            for ValidatorBalanceVerificationTargetsPublicInputs<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >
            where
                [(); VALIDATORS_COUNT / 4]:,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ValidatorBalanceVerificationTargetsPublicInputs",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "withdrawalCredentials",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    serde_bool_array_to_hex_string_nested::serialize(
                                        self.values.0,
                                        __s,
                                    )
                                }
                            }
                            &__SerializeWith {
                                values: (&self.withdrawal_credentials,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currentEpoch",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    biguint_to_str(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.current_epoch,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "rangeTotalValue",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    biguint_to_str(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.range_total_value,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "rangeBalancesRoot",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <Sha256Target as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    serde_bool_array_to_hex_string::serialize(
                                        self.values.0,
                                        __s,
                                    )
                                }
                            }
                            &__SerializeWith {
                                values: (&self.range_balances_root,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "rangeValidatorCommitment",
                        &self.range_validator_commitment,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "numberOfNonActivatedValidators",
                        &self.number_of_non_activated_validators,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "numberOfActiveValidators",
                        &self.number_of_active_validators,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "numberOfExittedValidators",
                        &self.number_of_exitted_validators,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<
                'de,
                const VALIDATORS_COUNT: usize,
                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
            > _serde::Deserialize<'de>
            for ValidatorBalanceVerificationTargetsPublicInputs<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >
            where
                [(); VALIDATORS_COUNT / 4]:,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "withdrawalCredentials" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "currentEpoch" => _serde::__private::Ok(__Field::__field1),
                                "rangeTotalValue" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "rangeBalancesRoot" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "rangeValidatorCommitment" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "numberOfNonActivatedValidators" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "numberOfActiveValidators" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "numberOfExittedValidators" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"withdrawalCredentials" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"currentEpoch" => _serde::__private::Ok(__Field::__field1),
                                b"rangeTotalValue" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"rangeBalancesRoot" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"rangeValidatorCommitment" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"numberOfNonActivatedValidators" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"numberOfActiveValidators" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"numberOfExittedValidators" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<
                        'de,
                        const VALIDATORS_COUNT: usize,
                        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                    >
                    where
                        [(); VALIDATORS_COUNT / 4]:,
                    {
                        marker: _serde::__private::PhantomData<
                            ValidatorBalanceVerificationTargetsPublicInputs<
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<
                        'de,
                        const VALIDATORS_COUNT: usize,
                        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                    > _serde::de::Visitor<'de>
                    for __Visitor<'de, VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
                    where
                        [(); VALIDATORS_COUNT / 4]:,
                    {
                        type Value = ValidatorBalanceVerificationTargetsPublicInputs<
                            VALIDATORS_COUNT,
                            WITHDRAWAL_CREDENTIALS_COUNT,
                        >;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ValidatorBalanceVerificationTargetsPublicInputs",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsPublicInputs<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: serde_bool_array_to_hex_string_nested::deserialize(
                                                __deserializer,
                                            )?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsPublicInputs<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: parse_biguint(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsPublicInputs<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: parse_biguint(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <Sha256Target as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsPublicInputs<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: serde_bool_array_to_hex_string::deserialize(
                                                __deserializer,
                                            )?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct ValidatorBalanceVerificationTargetsPublicInputs with 8 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ValidatorBalanceVerificationTargetsPublicInputs {
                                withdrawal_credentials: __field0,
                                current_epoch: __field1,
                                range_total_value: __field2,
                                range_balances_root: __field3,
                                range_validator_commitment: __field4,
                                number_of_non_activated_validators: __field5,
                                number_of_active_validators: __field6,
                                number_of_exitted_validators: __field7,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                <Sha256Target as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<
                                <Target as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "withdrawalCredentials",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: serde_bool_array_to_hex_string_nested::deserialize(
                                                            __deserializer,
                                                        )?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currentEpoch",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: parse_biguint(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "rangeTotalValue",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: parse_biguint(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "rangeBalancesRoot",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <Sha256Target as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsPublicInputs<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: serde_bool_array_to_hex_string::deserialize(
                                                            __deserializer,
                                                        )?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "rangeValidatorCommitment",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <HashOutTarget as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "numberOfNonActivatedValidators",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <Target as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "numberOfActiveValidators",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <Target as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "numberOfExittedValidators",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <Target as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "withdrawalCredentials",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "currentEpoch",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "rangeTotalValue",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "rangeBalancesRoot",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "rangeValidatorCommitment",
                                    )?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "numberOfNonActivatedValidators",
                                    )?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "numberOfActiveValidators",
                                    )?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "numberOfExittedValidators",
                                    )?
                                }
                            };
                            _serde::__private::Ok(ValidatorBalanceVerificationTargetsPublicInputs {
                                withdrawal_credentials: __field0,
                                current_epoch: __field1,
                                range_total_value: __field2,
                                range_balances_root: __field3,
                                range_validator_commitment: __field4,
                                number_of_non_activated_validators: __field5,
                                number_of_active_validators: __field6,
                                number_of_exitted_validators: __field7,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "withdrawalCredentials",
                        "currentEpoch",
                        "rangeTotalValue",
                        "rangeBalancesRoot",
                        "rangeValidatorCommitment",
                        "numberOfNonActivatedValidators",
                        "numberOfActiveValidators",
                        "numberOfExittedValidators",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ValidatorBalanceVerificationTargetsPublicInputs",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ValidatorBalanceVerificationTargetsPublicInputs<
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ValidatorBalanceVerificationTargetsPublicInputsTarget<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            pub withdrawal_credentials: [Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT],
            pub current_epoch: BigUintTarget,
            pub range_total_value: BigUintTarget,
            pub range_balances_root: Sha256Target,
            pub range_validator_commitment: HashOutTarget,
            pub number_of_non_activated_validators: Target,
            pub number_of_active_validators: Target,
            pub number_of_exitted_validators: Target,
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > ValidatorBalanceVerificationTargetsPublicInputsTarget<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            pub fn register_public_inputs<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                &self,
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) {
                builder
                    .register_public_inputs(
                        &<[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::ToTargets>::to_targets(
                            &self.withdrawal_credentials,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<BigUintTarget as circuit::ToTargets>::to_targets(
                            &self.current_epoch,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<BigUintTarget as circuit::ToTargets>::to_targets(
                            &self.range_total_value,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Sha256Target as circuit::ToTargets>::to_targets(
                            &self.range_balances_root,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<HashOutTarget as circuit::ToTargets>::to_targets(
                            &self.range_validator_commitment,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_non_activated_validators,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_active_validators,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_exitted_validators,
                        ),
                    );
            }
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > std::convert::From<
            ValidatorBalanceVerificationTargets<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >,
        >
        for ValidatorBalanceVerificationTargetsPublicInputsTarget<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            fn from(
                value: ValidatorBalanceVerificationTargets<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                >,
            ) -> ValidatorBalanceVerificationTargetsPublicInputsTarget<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            > {
                ValidatorBalanceVerificationTargetsPublicInputsTarget::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                > {
                    withdrawal_credentials: value.withdrawal_credentials,
                    current_epoch: value.current_epoch,
                    range_total_value: value.range_total_value,
                    range_balances_root: value.range_balances_root,
                    range_validator_commitment: value.range_validator_commitment,
                    number_of_non_activated_validators: value
                        .number_of_non_activated_validators,
                    number_of_active_validators: value.number_of_active_validators,
                    number_of_exitted_validators: value.number_of_exitted_validators,
                }
            }
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > circuit::TargetsWithPublicInputs
        for ValidatorBalanceVerificationTargets<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            type PublicInputs = ValidatorBalanceVerificationTargetsPublicInputs<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >;
            #[allow(unused_variables)]
            fn read_public_inputs<F: plonky2::hash::hash_types::RichField>(
                public_inputs: &[F],
            ) -> Self::PublicInputs {
                let mut reader = circuit::PublicInputsFieldReader::new(public_inputs);
                let withdrawal_credentials = reader
                    .read_object::<[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT]>();
                let current_epoch = reader.read_object::<BigUintTarget>();
                let range_total_value = reader.read_object::<BigUintTarget>();
                let range_balances_root = reader.read_object::<Sha256Target>();
                let range_validator_commitment = reader.read_object::<HashOutTarget>();
                let number_of_non_activated_validators = reader.read_object::<Target>();
                let number_of_active_validators = reader.read_object::<Target>();
                let number_of_exitted_validators = reader.read_object::<Target>();
                ValidatorBalanceVerificationTargetsPublicInputs::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                > {
                    withdrawal_credentials,
                    current_epoch,
                    range_total_value,
                    range_balances_root,
                    range_validator_commitment,
                    number_of_non_activated_validators,
                    number_of_active_validators,
                    number_of_exitted_validators,
                }
            }
            type PublicInputsTarget = ValidatorBalanceVerificationTargetsPublicInputsTarget<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >;
            #[allow(unused_variables)]
            fn read_public_inputs_target(
                public_inputs: &[plonky2::iop::target::Target],
            ) -> Self::PublicInputsTarget {
                let mut reader = circuit::PublicInputsTargetReader::new(public_inputs);
                let withdrawal_credentials = reader
                    .read_object::<[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT]>();
                let current_epoch = reader.read_object::<BigUintTarget>();
                let range_total_value = reader.read_object::<BigUintTarget>();
                let range_balances_root = reader.read_object::<Sha256Target>();
                let range_validator_commitment = reader.read_object::<HashOutTarget>();
                let number_of_non_activated_validators = reader.read_object::<Target>();
                let number_of_active_validators = reader.read_object::<Target>();
                let number_of_exitted_validators = reader.read_object::<Target>();
                ValidatorBalanceVerificationTargetsPublicInputsTarget::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                > {
                    withdrawal_credentials,
                    current_epoch,
                    range_total_value,
                    range_balances_root,
                    range_validator_commitment,
                    number_of_non_activated_validators,
                    number_of_active_validators,
                    number_of_exitted_validators,
                }
            }
            #[allow(unused_variables)]
            fn register_public_inputs<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                &self,
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) {
                builder
                    .register_public_inputs(
                        &<[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::ToTargets>::to_targets(
                            &self.withdrawal_credentials,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<BigUintTarget as circuit::ToTargets>::to_targets(
                            &self.current_epoch,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<BigUintTarget as circuit::ToTargets>::to_targets(
                            &self.range_total_value,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Sha256Target as circuit::ToTargets>::to_targets(
                            &self.range_balances_root,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<HashOutTarget as circuit::ToTargets>::to_targets(
                            &self.range_validator_commitment,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_non_activated_validators,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_active_validators,
                        ),
                    );
                builder
                    .register_public_inputs(
                        &<Target as circuit::ToTargets>::to_targets(
                            &self.number_of_exitted_validators,
                        ),
                    );
            }
        }
        #[serde(rename_all = "camelCase")]
        pub struct ValidatorBalanceVerificationTargetsWitnessInput<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            pub validators: <[ValidatorTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
            pub non_zero_validator_leaves_mask: <[BoolTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
            #[serde(with = "serde_bool_array_to_hex_string_nested")]
            pub balances_leaves: <[Sha256Target; VALIDATORS_COUNT
                / 4] as circuit::TargetPrimitive>::Primitive,
            #[serde(with = "serde_bool_array_to_hex_string_nested")]
            pub withdrawal_credentials: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
            #[serde(
                serialize_with = "biguint_to_str",
                deserialize_with = "parse_biguint"
            )]
            pub current_epoch: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
        }
        #[automatically_derived]
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > ::core::fmt::Debug
        for ValidatorBalanceVerificationTargetsWitnessInput<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ValidatorBalanceVerificationTargetsWitnessInput",
                    "validators",
                    &self.validators,
                    "non_zero_validator_leaves_mask",
                    &self.non_zero_validator_leaves_mask,
                    "balances_leaves",
                    &self.balances_leaves,
                    "withdrawal_credentials",
                    &self.withdrawal_credentials,
                    "current_epoch",
                    &&self.current_epoch,
                )
            }
        }
        #[automatically_derived]
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > ::core::clone::Clone
        for ValidatorBalanceVerificationTargetsWitnessInput<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            #[inline]
            fn clone(
                &self,
            ) -> ValidatorBalanceVerificationTargetsWitnessInput<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            > {
                ValidatorBalanceVerificationTargetsWitnessInput {
                    validators: ::core::clone::Clone::clone(&self.validators),
                    non_zero_validator_leaves_mask: ::core::clone::Clone::clone(
                        &self.non_zero_validator_leaves_mask,
                    ),
                    balances_leaves: ::core::clone::Clone::clone(&self.balances_leaves),
                    withdrawal_credentials: ::core::clone::Clone::clone(
                        &self.withdrawal_credentials,
                    ),
                    current_epoch: ::core::clone::Clone::clone(&self.current_epoch),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<
                const VALIDATORS_COUNT: usize,
                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
            > _serde::Serialize
            for ValidatorBalanceVerificationTargetsWitnessInput<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >
            where
                [(); VALIDATORS_COUNT / 4]:,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ValidatorBalanceVerificationTargetsWitnessInput",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "validators",
                        &self.validators,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "nonZeroValidatorLeavesMask",
                        &self.non_zero_validator_leaves_mask,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "balancesLeaves",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <[Sha256Target; VALIDATORS_COUNT
                                        / 4] as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    serde_bool_array_to_hex_string_nested::serialize(
                                        self.values.0,
                                        __s,
                                    )
                                }
                            }
                            &__SerializeWith {
                                values: (&self.balances_leaves,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "withdrawalCredentials",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    serde_bool_array_to_hex_string_nested::serialize(
                                        self.values.0,
                                        __s,
                                    )
                                }
                            }
                            &__SerializeWith {
                                values: (&self.withdrawal_credentials,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "currentEpoch",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                values: (
                                    &'__a <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                ),
                                phantom: _serde::__private::PhantomData<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                            impl<
                                '__a,
                                const VALIDATORS_COUNT: usize,
                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                            > _serde::Serialize
                            for __SerializeWith<
                                '__a,
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >
                            where
                                [(); VALIDATORS_COUNT / 4]:,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    biguint_to_str(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.current_epoch,),
                                phantom: _serde::__private::PhantomData::<
                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                        VALIDATORS_COUNT,
                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                    >,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<
                'de,
                const VALIDATORS_COUNT: usize,
                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
            > _serde::Deserialize<'de>
            for ValidatorBalanceVerificationTargetsWitnessInput<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >
            where
                [(); VALIDATORS_COUNT / 4]:,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "validators" => _serde::__private::Ok(__Field::__field0),
                                "nonZeroValidatorLeavesMask" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "balancesLeaves" => _serde::__private::Ok(__Field::__field2),
                                "withdrawalCredentials" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "currentEpoch" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"validators" => _serde::__private::Ok(__Field::__field0),
                                b"nonZeroValidatorLeavesMask" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"balancesLeaves" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"withdrawalCredentials" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"currentEpoch" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<
                        'de,
                        const VALIDATORS_COUNT: usize,
                        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                    >
                    where
                        [(); VALIDATORS_COUNT / 4]:,
                    {
                        marker: _serde::__private::PhantomData<
                            ValidatorBalanceVerificationTargetsWitnessInput<
                                VALIDATORS_COUNT,
                                WITHDRAWAL_CREDENTIALS_COUNT,
                            >,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<
                        'de,
                        const VALIDATORS_COUNT: usize,
                        const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                    > _serde::de::Visitor<'de>
                    for __Visitor<'de, VALIDATORS_COUNT, WITHDRAWAL_CREDENTIALS_COUNT>
                    where
                        [(); VALIDATORS_COUNT / 4]:,
                    {
                        type Value = ValidatorBalanceVerificationTargetsWitnessInput<
                            VALIDATORS_COUNT,
                            WITHDRAWAL_CREDENTIALS_COUNT,
                        >;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ValidatorBalanceVerificationTargetsWitnessInput",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                <[ValidatorTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ValidatorBalanceVerificationTargetsWitnessInput with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                <[BoolTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ValidatorBalanceVerificationTargetsWitnessInput with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <[Sha256Target; VALIDATORS_COUNT
                                        / 4] as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsWitnessInput<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: serde_bool_array_to_hex_string_nested::deserialize(
                                                __deserializer,
                                            )?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ValidatorBalanceVerificationTargetsWitnessInput with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsWitnessInput<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: serde_bool_array_to_hex_string_nested::deserialize(
                                                __deserializer,
                                            )?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ValidatorBalanceVerificationTargetsWitnessInput with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                    phantom: _serde::__private::PhantomData<
                                        ValidatorBalanceVerificationTargetsWitnessInput<
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    const VALIDATORS_COUNT: usize,
                                    const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                > _serde::Deserialize<'de>
                                for __DeserializeWith<
                                    'de,
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >
                                where
                                    [(); VALIDATORS_COUNT / 4]:,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: parse_biguint(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<
                                            'de,
                                            VALIDATORS_COUNT,
                                            WITHDRAWAL_CREDENTIALS_COUNT,
                                        >,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct ValidatorBalanceVerificationTargetsWitnessInput with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ValidatorBalanceVerificationTargetsWitnessInput {
                                validators: __field0,
                                non_zero_validator_leaves_mask: __field1,
                                balances_leaves: __field2,
                                withdrawal_credentials: __field3,
                                current_epoch: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                <[ValidatorTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                <[BoolTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                <[Sha256Target; VALIDATORS_COUNT
                                    / 4] as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "validators",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <[ValidatorTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "nonZeroValidatorLeavesMask",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                <[BoolTarget; VALIDATORS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "balancesLeaves",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <[Sha256Target; VALIDATORS_COUNT
                                                    / 4] as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: serde_bool_array_to_hex_string_nested::deserialize(
                                                            __deserializer,
                                                        )?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "withdrawalCredentials",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: serde_bool_array_to_hex_string_nested::deserialize(
                                                            __deserializer,
                                                        )?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "currentEpoch",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                value: <BigUintTarget as circuit::TargetPrimitive>::Primitive,
                                                phantom: _serde::__private::PhantomData<
                                                    ValidatorBalanceVerificationTargetsWitnessInput<
                                                        VALIDATORS_COUNT,
                                                        WITHDRAWAL_CREDENTIALS_COUNT,
                                                    >,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                const VALIDATORS_COUNT: usize,
                                                const WITHDRAWAL_CREDENTIALS_COUNT: usize,
                                            > _serde::Deserialize<'de>
                                            for __DeserializeWith<
                                                'de,
                                                VALIDATORS_COUNT,
                                                WITHDRAWAL_CREDENTIALS_COUNT,
                                            >
                                            where
                                                [(); VALIDATORS_COUNT / 4]:,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: parse_biguint(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<
                                                    'de,
                                                    VALIDATORS_COUNT,
                                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                                >,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("validators")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "nonZeroValidatorLeavesMask",
                                    )?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "balancesLeaves",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "withdrawalCredentials",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field(
                                            "currentEpoch",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ValidatorBalanceVerificationTargetsWitnessInput {
                                validators: __field0,
                                non_zero_validator_leaves_mask: __field1,
                                balances_leaves: __field2,
                                withdrawal_credentials: __field3,
                                current_epoch: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "validators",
                        "nonZeroValidatorLeavesMask",
                        "balancesLeaves",
                        "withdrawalCredentials",
                        "currentEpoch",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ValidatorBalanceVerificationTargetsWitnessInput",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ValidatorBalanceVerificationTargetsWitnessInput<
                                    VALIDATORS_COUNT,
                                    WITHDRAWAL_CREDENTIALS_COUNT,
                                >,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
            F: plonky2::hash::hash_types::RichField,
        > circuit::SetWitness<F>
        for ValidatorBalanceVerificationTargets<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            type Input = ValidatorBalanceVerificationTargetsWitnessInput<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >;
            #[allow(unused_variables)]
            fn set_witness(
                &self,
                witness: &mut plonky2::iop::witness::PartialWitness<F>,
                input: &Self::Input,
            ) {
                <[ValidatorTarget; VALIDATORS_COUNT] as circuit::SetWitness<
                    F,
                >>::set_witness(&self.validators, witness, &input.validators);
                <[BoolTarget; VALIDATORS_COUNT] as circuit::SetWitness<
                    F,
                >>::set_witness(
                    &self.non_zero_validator_leaves_mask,
                    witness,
                    &input.non_zero_validator_leaves_mask,
                );
                <[Sha256Target; VALIDATORS_COUNT
                    / 4] as circuit::SetWitness<
                    F,
                >>::set_witness(&self.balances_leaves, witness, &input.balances_leaves);
                <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::SetWitness<
                    F,
                >>::set_witness(
                    &self.withdrawal_credentials,
                    witness,
                    &input.withdrawal_credentials,
                );
                <BigUintTarget as circuit::SetWitness<
                    F,
                >>::set_witness(&self.current_epoch, witness, &input.current_epoch);
            }
        }
        pub struct ValidatorBalanceVerificationTargetsCircuitInputTarget<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            pub validators: [ValidatorTarget; VALIDATORS_COUNT],
            pub non_zero_validator_leaves_mask: [BoolTarget; VALIDATORS_COUNT],
            pub balances_leaves: [Sha256Target; VALIDATORS_COUNT / 4],
            pub withdrawal_credentials: [Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT],
            pub current_epoch: BigUintTarget,
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > circuit::AddVirtualTarget
        for ValidatorBalanceVerificationTargetsCircuitInputTarget<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            fn add_virtual_target<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) -> Self {
                let validators = <[ValidatorTarget; VALIDATORS_COUNT] as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                );
                let non_zero_validator_leaves_mask = <[BoolTarget; VALIDATORS_COUNT] as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                );
                let balances_leaves = <[Sha256Target; VALIDATORS_COUNT
                    / 4] as circuit::AddVirtualTarget>::add_virtual_target(builder);
                let withdrawal_credentials = <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                );
                let current_epoch = <BigUintTarget as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                );
                ValidatorBalanceVerificationTargetsCircuitInputTarget::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                > {
                    validators,
                    non_zero_validator_leaves_mask,
                    balances_leaves,
                    withdrawal_credentials,
                    current_epoch,
                }
            }
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > circuit::ReadableCircuitInputTarget
        for ValidatorBalanceVerificationTargets<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            type CircuitInputTarget = ValidatorBalanceVerificationTargetsCircuitInputTarget<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >;
            fn read_circuit_input_target<
                F: plonky2::hash::hash_types::RichField
                    + plonky2::field::extension::Extendable<D>,
                const D: usize,
            >(
                builder: &mut plonky2::plonk::circuit_builder::CircuitBuilder<F, D>,
            ) -> Self::CircuitInputTarget {
                <Self::CircuitInputTarget as circuit::AddVirtualTarget>::add_virtual_target(
                    builder,
                )
            }
        }
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > circuit::SerdeCircuitTarget
        for ValidatorBalanceVerificationTargets<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            fn serialize(&self) -> plonky2::util::serialization::IoResult<Vec<u8>> {
                let mut buffer: Vec<u8> = Vec::new();
                buffer
                    .extend(
                        <[ValidatorTarget; VALIDATORS_COUNT] as circuit::SerdeCircuitTarget>::serialize(
                            &self.validators,
                        )?,
                    );
                buffer
                    .extend(
                        <[BoolTarget; VALIDATORS_COUNT] as circuit::SerdeCircuitTarget>::serialize(
                            &self.non_zero_validator_leaves_mask,
                        )?,
                    );
                buffer
                    .extend(
                        <[Sha256Target; VALIDATORS_COUNT
                            / 4] as circuit::SerdeCircuitTarget>::serialize(
                            &self.balances_leaves,
                        )?,
                    );
                buffer
                    .extend(
                        <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::SerdeCircuitTarget>::serialize(
                            &self.withdrawal_credentials,
                        )?,
                    );
                buffer
                    .extend(
                        <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.current_epoch,
                        )?,
                    );
                buffer
                    .extend(
                        <BigUintTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.range_total_value,
                        )?,
                    );
                buffer
                    .extend(
                        <Sha256Target as circuit::SerdeCircuitTarget>::serialize(
                            &self.range_balances_root,
                        )?,
                    );
                buffer
                    .extend(
                        <HashOutTarget as circuit::SerdeCircuitTarget>::serialize(
                            &self.range_validator_commitment,
                        )?,
                    );
                buffer
                    .extend(
                        <Target as circuit::SerdeCircuitTarget>::serialize(
                            &self.number_of_non_activated_validators,
                        )?,
                    );
                buffer
                    .extend(
                        <Target as circuit::SerdeCircuitTarget>::serialize(
                            &self.number_of_active_validators,
                        )?,
                    );
                buffer
                    .extend(
                        <Target as circuit::SerdeCircuitTarget>::serialize(
                            &self.number_of_exitted_validators,
                        )?,
                    );
                Ok(buffer)
            }
            fn deserialize(
                buffer: &mut plonky2::util::serialization::Buffer,
            ) -> plonky2::util::serialization::IoResult<Self>
            where
                Self: Sized,
            {
                Ok(Self {
                    validators: <[ValidatorTarget; VALIDATORS_COUNT] as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    non_zero_validator_leaves_mask: <[BoolTarget; VALIDATORS_COUNT] as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    balances_leaves: <[Sha256Target; VALIDATORS_COUNT
                        / 4] as circuit::SerdeCircuitTarget>::deserialize(buffer)?,
                    withdrawal_credentials: <[Sha256Target; WITHDRAWAL_CREDENTIALS_COUNT] as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    current_epoch: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    range_total_value: <BigUintTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    range_balances_root: <Sha256Target as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    range_validator_commitment: <HashOutTarget as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    number_of_non_activated_validators: <Target as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    number_of_active_validators: <Target as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                    number_of_exitted_validators: <Target as circuit::SerdeCircuitTarget>::deserialize(
                        buffer,
                    )?,
                })
            }
        }
        type F = GoldilocksField;
        type C = PoseidonGoldilocksConfig;
        const D: usize = 2;
        pub struct WithdrawalCredentialsBalanceAggregatorFirstLevel<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {}
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > Circuit
        for WithdrawalCredentialsBalanceAggregatorFirstLevel<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            type F = F;
            type C = C;
            const D: usize = D;
            const CIRCUIT_CONFIG: CircuitConfig = CircuitConfig::standard_recursion_config();
            type Target = ValidatorBalanceVerificationTargets<
                VALIDATORS_COUNT,
                WITHDRAWAL_CREDENTIALS_COUNT,
            >;
            type Params = ();
            fn define(builder: &mut CircuitBuilder<F, D>, _params: &()) -> Self::Target {
                if !VALIDATORS_COUNT.is_power_of_two() {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("validators_len must be a power of two"),
                        );
                    };
                }
                let input = Self::read_circuit_input_target(builder);
                let balances_hash_tree_root_poseidon = hash_tree_root_new(
                    builder,
                    &input.balances_leaves,
                );
                let validators_leaves = input
                    .validators
                    .iter()
                    .zip(input.non_zero_validator_leaves_mask)
                    .map(|(validator, is_not_zero)| {
                        hash_validator_poseidon_or_zeroes(
                            builder,
                            &validator,
                            is_not_zero,
                        )
                    })
                    .collect_vec();
                let validators_hash_tree_root_poseidon = hash_tree_root_poseidon_new(
                    builder,
                    &validators_leaves,
                );
                let mut sum = builder.zero_biguint();
                let mut number_of_non_activated_validators = builder.zero();
                let mut number_of_active_validators = builder.zero();
                let mut number_of_exitted_validators = builder.zero();
                for i in 0..VALIDATORS_COUNT {
                    let mut is_equal = builder._false();
                    for j in 0..WITHDRAWAL_CREDENTIALS_COUNT {
                        let is_equal_inner = bool_arrays_are_equal(
                            builder,
                            &input.validators[i].withdrawal_credentials,
                            &input.withdrawal_credentials[j],
                        );
                        is_equal = builder.or(is_equal_inner, is_equal);
                    }
                    let balance = ssz_num_from_bits(
                        builder,
                        &input
                            .balances_leaves[i
                            / 4][((i % 4) * 64)..(((i % 4) * 64) + 64)],
                    );
                    let zero = builder.zero_biguint();
                    let (
                        is_non_activated_validator,
                        is_valid_validator,
                        is_exited_validator,
                    ) = get_validator_status(
                        builder,
                        &input.validators[i].activation_epoch,
                        &input.current_epoch,
                        &input.validators[i].exit_epoch,
                    );
                    let will_be_counted = builder.and(is_equal, is_valid_validator);
                    let current = select_biguint(
                        builder,
                        will_be_counted,
                        &balance,
                        &zero,
                    );
                    sum = builder.add_biguint(&sum, &current);
                    number_of_active_validators = builder
                        .add(number_of_active_validators, will_be_counted.target);
                    let will_be_counted = builder
                        .and(is_equal, is_non_activated_validator);
                    number_of_non_activated_validators = builder
                        .add(number_of_non_activated_validators, will_be_counted.target);
                    let will_be_counted = builder.and(is_equal, is_exited_validator);
                    number_of_exitted_validators = builder
                        .add(number_of_exitted_validators, will_be_counted.target);
                    sum.limbs.pop();
                }
                Self::Target {
                    non_zero_validator_leaves_mask: input.non_zero_validator_leaves_mask,
                    range_total_value: sum,
                    range_balances_root: balances_hash_tree_root_poseidon,
                    range_validator_commitment: validators_hash_tree_root_poseidon,
                    validators: input.validators,
                    balances_leaves: input.balances_leaves,
                    withdrawal_credentials: input.withdrawal_credentials,
                    current_epoch: input.current_epoch,
                    number_of_non_activated_validators,
                    number_of_active_validators,
                    number_of_exitted_validators,
                }
            }
        }
    }
    pub mod inner_level {
        use crate::{
            common_targets::BasicRecursiveInnerCircuitTarget,
            utils::{
                biguint::CircuitBuilderBiguint,
                hashing::{
                    poseidon::poseidon_pair, sha256::{connect_bool_arrays, sha256_pair},
                },
            },
            withdrawal_credentials_balance_aggregator::first_level::WithdrawalCredentialsBalanceAggregatorFirstLevel,
        };
        use circuit::{Circuit, CircuitOutputTarget};
        use plonky2::{
            field::goldilocks_field::GoldilocksField,
            plonk::{
                circuit_builder::CircuitBuilder,
                circuit_data::{CircuitConfig, CircuitData, VerifierCircuitTarget},
                config::PoseidonGoldilocksConfig,
            },
        };
        const D: usize = 2;
        pub struct WithdrawalCredentialsBalanceAggregatorInnerLevel<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {}
        impl<
            const VALIDATORS_COUNT: usize,
            const WITHDRAWAL_CREDENTIALS_COUNT: usize,
        > Circuit
        for WithdrawalCredentialsBalanceAggregatorInnerLevel<
            VALIDATORS_COUNT,
            WITHDRAWAL_CREDENTIALS_COUNT,
        >
        where
            [(); VALIDATORS_COUNT / 4]:,
        {
            type F = GoldilocksField;
            type C = PoseidonGoldilocksConfig;
            const D: usize = D;
            const CIRCUIT_CONFIG: CircuitConfig = CircuitConfig::standard_recursion_config();
            type Target = BasicRecursiveInnerCircuitTarget;
            type Params = CircuitData<Self::F, Self::C, D>;
            fn define(
                builder: &mut CircuitBuilder<Self::F, D>,
                circuit_data: &Self::Params,
            ) -> Self::Target {
                let verifier_circuit_target = VerifierCircuitTarget {
                    constants_sigmas_cap: builder
                        .constant_merkle_cap(
                            &circuit_data.verifier_only.constants_sigmas_cap,
                        ),
                    circuit_digest: builder
                        .constant_hash(circuit_data.verifier_only.circuit_digest),
                };
                let proof1 = builder.add_virtual_proof_with_pis(&circuit_data.common);
                let proof2 = builder.add_virtual_proof_with_pis(&circuit_data.common);
                builder
                    .verify_proof::<
                        Self::C,
                    >(&proof1, &verifier_circuit_target, &circuit_data.common);
                builder
                    .verify_proof::<
                        Self::C,
                    >(&proof2, &verifier_circuit_target, &circuit_data.common);
                let l_input = WithdrawalCredentialsBalanceAggregatorFirstLevel::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                >::read_public_inputs_target(&proof1.public_inputs);
                let r_input = WithdrawalCredentialsBalanceAggregatorFirstLevel::<
                    VALIDATORS_COUNT,
                    WITHDRAWAL_CREDENTIALS_COUNT,
                >::read_public_inputs_target(&proof2.public_inputs);
                let range_validator_commitment = poseidon_pair(
                    builder,
                    l_input.range_validator_commitment,
                    r_input.range_validator_commitment,
                );
                let range_balances_root = sha256_pair(
                    builder,
                    &l_input.range_balances_root,
                    &r_input.range_balances_root,
                );
                let number_of_non_activated_validators = builder
                    .add(
                        l_input.number_of_non_activated_validators,
                        r_input.number_of_non_activated_validators,
                    );
                let number_of_active_validators = builder
                    .add(
                        l_input.number_of_active_validators,
                        r_input.number_of_active_validators,
                    );
                let number_of_exitted_validators = builder
                    .add(
                        l_input.number_of_exitted_validators,
                        r_input.number_of_exitted_validators,
                    );
                let mut range_total_value = builder
                    .add_biguint(&l_input.range_total_value, &r_input.range_total_value);
                range_total_value.limbs.pop();
                for i in 0..WITHDRAWAL_CREDENTIALS_COUNT {
                    connect_bool_arrays(
                        builder,
                        &l_input.withdrawal_credentials[i],
                        &r_input.withdrawal_credentials[i],
                    );
                }
                builder.connect_biguint(&l_input.current_epoch, &r_input.current_epoch);
                let output_target = CircuitOutputTarget::<
                    WithdrawalCredentialsBalanceAggregatorFirstLevel<
                        VALIDATORS_COUNT,
                        WITHDRAWAL_CREDENTIALS_COUNT,
                    >,
                > {
                    current_epoch: l_input.current_epoch,
                    range_total_value,
                    range_balances_root,
                    withdrawal_credentials: l_input.withdrawal_credentials,
                    range_validator_commitment,
                    number_of_non_activated_validators,
                    number_of_active_validators,
                    number_of_exitted_validators,
                };
                output_target.register_public_inputs(builder);
                Self::Target {
                    proof1,
                    proof2,
                    verifier_circuit_target,
                }
            }
        }
    }
}
